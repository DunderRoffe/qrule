//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   RSet    ********************/
RSet::RSet(ListRule *p1)
{
  listrule_ = p1;

}

RSet::RSet(const RSet & other)
{
  listrule_ = other.listrule_->clone();

}

RSet &RSet::operator=(const RSet & other)
{
  RSet tmp(other);
  swap(tmp);
  return *this;
}

void RSet::swap(RSet & other)
{
  std::swap(listrule_, other.listrule_);

}

RSet::~RSet()
{
  delete(listrule_);

}

RetType* RSet::accept(Visitor *v) {
  return v->visitRSet(this);
}

RSet *RSet::clone() const
{
  return new RSet(*this);
}



/********************   RRule    ********************/
RRule::RRule(Tag *p1, Severity *p2, RuleCause *p3, ASTScope *p4, Explanation *p5, Expr *p6)
{
  tag_ = p1;
  severity_ = p2;
  rulecause_ = p3;
  astscope_ = p4;
  explanation_ = p5;
  expr_ = p6;

}

RRule::RRule(const RRule & other)
{
  tag_ = other.tag_->clone();
  severity_ = other.severity_->clone();
  rulecause_ = other.rulecause_->clone();
  astscope_ = other.astscope_->clone();
  explanation_ = other.explanation_->clone();
  expr_ = other.expr_->clone();

}

RRule &RRule::operator=(const RRule & other)
{
  RRule tmp(other);
  swap(tmp);
  return *this;
}

void RRule::swap(RRule & other)
{
  std::swap(tag_, other.tag_);
  std::swap(severity_, other.severity_);
  std::swap(rulecause_, other.rulecause_);
  std::swap(astscope_, other.astscope_);
  std::swap(explanation_, other.explanation_);
  std::swap(expr_, other.expr_);

}

RRule::~RRule()
{
  delete(tag_);
  delete(severity_);
  delete(rulecause_);
  delete(astscope_);
  delete(explanation_);
  delete(expr_);

}

RetType* RRule::accept(Visitor *v) {
  return v->visitRRule(this);
}

RRule *RRule::clone() const
{
  return new RRule(*this);
}



/********************   ASTGlobally    ********************/
ASTGlobally::ASTGlobally()
{

}

ASTGlobally::ASTGlobally(const ASTGlobally & other)
{

}

ASTGlobally &ASTGlobally::operator=(const ASTGlobally & other)
{
  ASTGlobally tmp(other);
  swap(tmp);
  return *this;
}

void ASTGlobally::swap(ASTGlobally & other)
{

}

ASTGlobally::~ASTGlobally()
{

}

RetType* ASTGlobally::accept(Visitor *v) {
    return v->visitASTGlobally(this);
}

ASTGlobally *ASTGlobally::clone() const
{
  return new ASTGlobally(*this);
}



/********************   ASTFile    ********************/
ASTFile::ASTFile()
{

}

ASTFile::ASTFile(const ASTFile & other)
{

}

ASTFile &ASTFile::operator=(const ASTFile & other)
{
  ASTFile tmp(other);
  swap(tmp);
  return *this;
}

void ASTFile::swap(ASTFile & other)
{

}

ASTFile::~ASTFile()
{

}

RetType* ASTFile::accept(Visitor *v) {
    return v->visitASTFile(this);
}

ASTFile *ASTFile::clone() const
{
  return new ASTFile(*this);
}



/********************   ASTImported    ********************/
ASTImported::ASTImported()
{

}

ASTImported::ASTImported(const ASTImported & other)
{

}

ASTImported &ASTImported::operator=(const ASTImported & other)
{
  ASTImported tmp(other);
  swap(tmp);
  return *this;
}

void ASTImported::swap(ASTImported & other)
{

}

ASTImported::~ASTImported()
{

}

RetType* ASTImported::accept(Visitor *v) {
    return v->visitASTImported(this);
}

ASTImported *ASTImported::clone() const
{
  return new ASTImported(*this);
}



/********************   RCLang    ********************/
RCLang::RCLang()
{

}

RCLang::RCLang(const RCLang & other)
{

}

RCLang &RCLang::operator=(const RCLang & other)
{
  RCLang tmp(other);
  swap(tmp);
  return *this;
}

void RCLang::swap(RCLang & other)
{

}

RCLang::~RCLang()
{

}

RetType* RCLang::accept(Visitor *v) {
    return v->visitRCLang(this);
}

RCLang *RCLang::clone() const
{
  return new RCLang(*this);
}



/********************   RCPolicy    ********************/
RCPolicy::RCPolicy()
{

}

RCPolicy::RCPolicy(const RCPolicy & other)
{

}

RCPolicy &RCPolicy::operator=(const RCPolicy & other)
{
  RCPolicy tmp(other);
  swap(tmp);
  return *this;
}

void RCPolicy::swap(RCPolicy & other)
{

}

RCPolicy::~RCPolicy()
{

}

RetType* RCPolicy::accept(Visitor *v) {
    return v->visitRCPolicy(this);
}

RCPolicy *RCPolicy::clone() const
{
  return new RCPolicy(*this);
}



/********************   Explan    ********************/
Explan::Explan(String p1)
{
  string_ = p1;

}

Explan::Explan(const Explan & other)
{
  string_ = other.string_;

}

Explan &Explan::operator=(const Explan & other)
{
  Explan tmp(other);
  swap(tmp);
  return *this;
}

void Explan::swap(Explan & other)
{
  std::swap(string_, other.string_);

}

Explan::~Explan()
{

}

RetType* Explan::accept(Visitor *v) {
    return v->visitExplan(this);
}

Explan *Explan::clone() const
{
  return new Explan(*this);
}



/********************   Noexplan    ********************/
Noexplan::Noexplan()
{

}

Noexplan::Noexplan(const Noexplan & other)
{

}

Noexplan &Noexplan::operator=(const Noexplan & other)
{
  Noexplan tmp(other);
  swap(tmp);
  return *this;
}

void Noexplan::swap(Noexplan & other)
{

}

Noexplan::~Noexplan()
{

}

RetType* Noexplan::accept(Visitor *v) {
    return v->visitNoexplan(this);
}

Noexplan *Noexplan::clone() const
{
  return new Noexplan(*this);
}



/********************   TTag    ********************/
TTag::TTag(String p1)
{
  string_ = p1;

}

TTag::TTag(const TTag & other)
{
  string_ = other.string_;

}

TTag &TTag::operator=(const TTag & other)
{
  TTag tmp(other);
  swap(tmp);
  return *this;
}

void TTag::swap(TTag & other)
{
  std::swap(string_, other.string_);

}

TTag::~TTag()
{

}

RetType* TTag::accept(Visitor *v) {
    return v->visitTTag(this);
}

TTag *TTag::clone() const
{
  return new TTag(*this);
}



/********************   SevWarning    ********************/
SevWarning::SevWarning()
{

}

SevWarning::SevWarning(const SevWarning & other)
{

}

SevWarning &SevWarning::operator=(const SevWarning & other)
{
  SevWarning tmp(other);
  swap(tmp);
  return *this;
}

void SevWarning::swap(SevWarning & other)
{

}

SevWarning::~SevWarning()
{

}

RetType* SevWarning::accept(Visitor *v) {
    return v->visitSevWarning(this);
}

SevWarning *SevWarning::clone() const
{
  return new SevWarning(*this);
}



/********************   SevCritical    ********************/
SevCritical::SevCritical()
{

}

SevCritical::SevCritical(const SevCritical & other)
{

}

SevCritical &SevCritical::operator=(const SevCritical & other)
{
  SevCritical tmp(other);
  swap(tmp);
  return *this;
}

void SevCritical::swap(SevCritical & other)
{

}

SevCritical::~SevCritical()
{

}

RetType* SevCritical::accept(Visitor *v) {
    return v->visitSevCritical(this);
}

SevCritical *SevCritical::clone() const
{
  return new SevCritical(*this);
}



/********************   All    ********************/
All::All(PathSpecific *p1)
{
  pathspecific_ = p1;

}

All::All(const All & other)
{
  pathspecific_ = other.pathspecific_->clone();

}

All &All::operator=(const All & other)
{
  All tmp(other);
  swap(tmp);
  return *this;
}

void All::swap(All & other)
{
  std::swap(pathspecific_, other.pathspecific_);

}

All::~All()
{
  delete(pathspecific_);

}

RetType* All::accept(Visitor *v) {
    return v->visitAll(this);
}

All *All::clone() const
{
  return new All(*this);
}



/********************   Exist    ********************/
Exist::Exist(PathSpecific *p1)
{
  pathspecific_ = p1;

}

Exist::Exist(const Exist & other)
{
  pathspecific_ = other.pathspecific_->clone();

}

Exist &Exist::operator=(const Exist & other)
{
  Exist tmp(other);
  swap(tmp);
  return *this;
}

void Exist::swap(Exist & other)
{
  std::swap(pathspecific_, other.pathspecific_);

}

Exist::~Exist()
{
  delete(pathspecific_);

}

RetType* Exist::accept(Visitor *v) {
    return v->visitExist(this);
}

Exist *Exist::clone() const
{
  return new Exist(*this);
}



/********************   Future    ********************/
Future::Future(Expr *p1)
{
  expr_ = p1;

}

Future::Future(const Future & other)
{
  expr_ = other.expr_->clone();

}

Future &Future::operator=(const Future & other)
{
  Future tmp(other);
  swap(tmp);
  return *this;
}

void Future::swap(Future & other)
{
  std::swap(expr_, other.expr_);

}

Future::~Future()
{
  delete(expr_);

}

RetType* Future::accept(Visitor *v) {
    return v->visitFuture(this);
}

Future *Future::clone() const
{
  return new Future(*this);
}



/********************   Globally    ********************/
Globally::Globally(Expr *p1)
{
  expr_ = p1;

}

Globally::Globally(const Globally & other)
{
  expr_ = other.expr_->clone();

}

Globally &Globally::operator=(const Globally & other)
{
  Globally tmp(other);
  swap(tmp);
  return *this;
}

void Globally::swap(Globally & other)
{
  std::swap(expr_, other.expr_);

}

Globally::~Globally()
{
  delete(expr_);

}

RetType* Globally::accept(Visitor *v) {
    return v->visitGlobally(this);
}

Globally *Globally::clone() const
{
  return new Globally(*this);
}



/********************   Until    ********************/
Until::Until(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Until::Until(const Until & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Until &Until::operator=(const Until & other)
{
  Until tmp(other);
  swap(tmp);
  return *this;
}

void Until::swap(Until & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Until::~Until()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* Until::accept(Visitor *v) {
    return v->visitUntil(this);
}

Until *Until::clone() const
{
  return new Until(*this);
}



/********************   Next    ********************/
Next::Next(Expr *p1)
{
  expr_ = p1;

}

Next::Next(const Next & other)
{
  expr_ = other.expr_->clone();

}

Next &Next::operator=(const Next & other)
{
  Next tmp(other);
  swap(tmp);
  return *this;
}

void Next::swap(Next & other)
{
  std::swap(expr_, other.expr_);

}

Next::~Next()
{
  delete(expr_);

}

RetType* Next::accept(Visitor *v) {
    return v->visitNext(this);
}

Next *Next::clone() const
{
  return new Next(*this);
}



/********************   IEInt    ********************/
IEInt::IEInt(Integer p1)
{
  integer_ = p1;

}

IEInt::IEInt(const IEInt & other)
{
  integer_ = other.integer_;

}

IEInt &IEInt::operator=(const IEInt & other)
{
  IEInt tmp(other);
  swap(tmp);
  return *this;
}

void IEInt::swap(IEInt & other)
{
  std::swap(integer_, other.integer_);

}

IEInt::~IEInt()
{

}

RetType* IEInt::accept(Visitor *v) {
    return v->visitIEInt(this);
}

IEInt *IEInt::clone() const
{
  return new IEInt(*this);
}



/********************   IENrChildren    ********************/
IENrChildren::IENrChildren()
{

}

IENrChildren::IENrChildren(const IENrChildren & other)
{

}

IENrChildren &IENrChildren::operator=(const IENrChildren & other)
{
  IENrChildren tmp(other);
  swap(tmp);
  return *this;
}

void IENrChildren::swap(IENrChildren & other)
{

}

IENrChildren::~IENrChildren()
{

}

RetType* IENrChildren::accept(Visitor *v) {
    return v->visitIENrChildren(this);
}

IENrChildren *IENrChildren::clone() const
{
  return new IENrChildren(*this);
}



/********************   IELtEq    ********************/
IELtEq::IELtEq(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IELtEq::IELtEq(const IELtEq & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IELtEq &IELtEq::operator=(const IELtEq & other)
{
  IELtEq tmp(other);
  swap(tmp);
  return *this;
}

void IELtEq::swap(IELtEq & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IELtEq::~IELtEq()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IELtEq::accept(Visitor *v) {
    return v->visitIELtEq(this);
}

IELtEq *IELtEq::clone() const
{
  return new IELtEq(*this);
}



/********************   IEGtEq    ********************/
IEGtEq::IEGtEq(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IEGtEq::IEGtEq(const IEGtEq & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IEGtEq &IEGtEq::operator=(const IEGtEq & other)
{
  IEGtEq tmp(other);
  swap(tmp);
  return *this;
}

void IEGtEq::swap(IEGtEq & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IEGtEq::~IEGtEq()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IEGtEq::accept(Visitor *v) {
    return v->visitIEGtEq(this);
}

IEGtEq *IEGtEq::clone() const
{
  return new IEGtEq(*this);
}



/********************   IELt    ********************/
IELt::IELt(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IELt::IELt(const IELt & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IELt &IELt::operator=(const IELt & other)
{
  IELt tmp(other);
  swap(tmp);
  return *this;
}

void IELt::swap(IELt & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IELt::~IELt()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IELt::accept(Visitor *v) {
    return v->visitIELt(this);
}

IELt *IELt::clone() const
{
  return new IELt(*this);
}



/********************   IEGt    ********************/
IEGt::IEGt(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IEGt::IEGt(const IEGt & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IEGt &IEGt::operator=(const IEGt & other)
{
  IEGt tmp(other);
  swap(tmp);
  return *this;
}

void IEGt::swap(IEGt & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IEGt::~IEGt()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IEGt::accept(Visitor *v) {
    return v->visitIEGt(this);
}

IEGt *IEGt::clone() const
{
  return new IEGt(*this);
}



/********************   IEq    ********************/
IEq::IEq(IStmnt *p1, IStmnt *p2)
{
  istmnt_1 = p1;
  istmnt_2 = p2;

}

IEq::IEq(const IEq & other)
{
  istmnt_1 = other.istmnt_1->clone();
  istmnt_2 = other.istmnt_2->clone();

}

IEq &IEq::operator=(const IEq & other)
{
  IEq tmp(other);
  swap(tmp);
  return *this;
}

void IEq::swap(IEq & other)
{
  std::swap(istmnt_1, other.istmnt_1);
  std::swap(istmnt_2, other.istmnt_2);

}

IEq::~IEq()
{
  delete(istmnt_1);
  delete(istmnt_2);

}

RetType* IEq::accept(Visitor *v) {
    return v->visitIEq(this);
}

IEq *IEq::clone() const
{
  return new IEq(*this);
}



/********************   IEStmnt    ********************/
IEStmnt::IEStmnt(IStmnt *p1)
{
  istmnt_ = p1;

}

IEStmnt::IEStmnt(const IEStmnt & other)
{
  istmnt_ = other.istmnt_->clone();

}

IEStmnt &IEStmnt::operator=(const IEStmnt & other)
{
  IEStmnt tmp(other);
  swap(tmp);
  return *this;
}

void IEStmnt::swap(IEStmnt & other)
{
  std::swap(istmnt_, other.istmnt_);

}

IEStmnt::~IEStmnt()
{
  delete(istmnt_);

}

RetType* IEStmnt::accept(Visitor *v) {
    return v->visitIEStmnt(this);
}

IEStmnt *IEStmnt::clone() const
{
  return new IEStmnt(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

RetType* ETrue::accept(Visitor *v) {
    return v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

RetType* EFalse::accept(Visitor *v) {
    return v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   ENodeVal    ********************/
ENodeVal::ENodeVal(String p1)
{
  string_ = p1;

}

ENodeVal::ENodeVal(const ENodeVal & other)
{
  string_ = other.string_;

}

ENodeVal &ENodeVal::operator=(const ENodeVal & other)
{
  ENodeVal tmp(other);
  swap(tmp);
  return *this;
}

void ENodeVal::swap(ENodeVal & other)
{
  std::swap(string_, other.string_);

}

ENodeVal::~ENodeVal()
{

}

RetType* ENodeVal::accept(Visitor *v) {
    return v->visitENodeVal(this);
}

ENodeVal *ENodeVal::clone() const
{
  return new ENodeVal(*this);
}



/********************   EType    ********************/
EType::EType(Type *p1)
{
  type_ = p1;

}

EType::EType(const EType & other)
{
  type_ = other.type_->clone();

}

EType &EType::operator=(const EType & other)
{
  EType tmp(other);
  swap(tmp);
  return *this;
}

void EType::swap(EType & other)
{
  std::swap(type_, other.type_);

}

EType::~EType()
{
  delete(type_);

}

RetType* EType::accept(Visitor *v) {
  v->visitEType(this);
}

EType *EType::clone() const
{
  return new EType(*this);
}



/********************   EParant    ********************/
EParant::EParant(Expr *p1)
{
  expr_ = p1;

}

EParant::EParant(const EParant & other)
{
  expr_ = other.expr_->clone();

}

EParant &EParant::operator=(const EParant & other)
{
  EParant tmp(other);
  swap(tmp);
  return *this;
}

void EParant::swap(EParant & other)
{
  std::swap(expr_, other.expr_);

}

EParant::~EParant()
{
  delete(expr_);

}

RetType* EParant::accept(Visitor *v) {
    return v->visitEParant(this);
}

EParant *EParant::clone() const
{
  return new EParant(*this);
}



/********************   ENot    ********************/
ENot::ENot(Expr *p1)
{
  expr_ = p1;

}

ENot::ENot(const ENot & other)
{
  expr_ = other.expr_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(expr_, other.expr_);

}

ENot::~ENot()
{
  delete(expr_);

}

RetType* ENot::accept(Visitor *v) {
    return v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}



/********************   EImpl    ********************/
EImpl::EImpl(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EImpl::EImpl(const EImpl & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EImpl &EImpl::operator=(const EImpl & other)
{
  EImpl tmp(other);
  swap(tmp);
  return *this;
}

void EImpl::swap(EImpl & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EImpl::~EImpl()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EImpl::accept(Visitor *v) {
    return v->visitEImpl(this);
}

EImpl *EImpl::clone() const
{
  return new EImpl(*this);
}



/********************   EIExpr    ********************/
EIExpr::EIExpr(IExpr *p1)
{
  iexpr_ = p1;

}

EIExpr::EIExpr(const EIExpr & other)
{
  iexpr_ = other.iexpr_->clone();

}

EIExpr &EIExpr::operator=(const EIExpr & other)
{
  EIExpr tmp(other);
  swap(tmp);
  return *this;
}

void EIExpr::swap(EIExpr & other)
{
  std::swap(iexpr_, other.iexpr_);

}

EIExpr::~EIExpr()
{
  delete(iexpr_);

}

RetType* EIExpr::accept(Visitor *v) {
    return v->visitEIExpr(this);
}

EIExpr *EIExpr::clone() const
{
  return new EIExpr(*this);
}



/********************   EEq    ********************/
EEq::EEq(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EEq::EEq(const EEq & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EEq::~EEq()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EEq::accept(Visitor *v) {
    return v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EAnd::accept(Visitor *v) {
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EOr::accept(Visitor *v) {
    return v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EOverPaths    ********************/
EOverPaths::EOverPaths(OverPaths *p1)
{
  overpaths_ = p1;

}

EOverPaths::EOverPaths(const EOverPaths & other)
{
  overpaths_ = other.overpaths_->clone();

}

EOverPaths &EOverPaths::operator=(const EOverPaths & other)
{
  EOverPaths tmp(other);
  swap(tmp);
  return *this;
}

void EOverPaths::swap(EOverPaths & other)
{
  std::swap(overpaths_, other.overpaths_);

}

EOverPaths::~EOverPaths()
{
  delete(overpaths_);

}

RetType* EOverPaths::accept(Visitor *v) {
    return v->visitEOverPaths(this);
}

EOverPaths *EOverPaths::clone() const
{
  return new EOverPaths(*this);
}



/********************   TType    ********************/
TType::TType(String p1)
{
  string_ = p1;

}

TType::TType(const TType & other)
{
  string_ = other.string_;

}

TType &TType::operator=(const TType & other)
{
  TType tmp(other);
  swap(tmp);
  return *this;
}

void TType::swap(TType & other)
{
  std::swap(string_, other.string_);

}

TType::~TType()
{

}

RetType* TType::accept(Visitor *v) {
    return v->visitTType(this);
}

TType *TType::clone() const
{
  return new TType(*this);
}



/********************   PParam    ********************/
PParam::PParam(String p1)
{
  string_ = p1;

}

PParam::PParam(const PParam & other)
{
  string_ = other.string_;

}

PParam &PParam::operator=(const PParam & other)
{
  PParam tmp(other);
  swap(tmp);
  return *this;
}

void PParam::swap(PParam & other)
{
  std::swap(string_, other.string_);

}

PParam::~PParam()
{

}

RetType* PParam::accept(Visitor *v) {
    return v->visitPParam(this);
}

PParam *PParam::clone() const
{
  return new PParam(*this);
}




/********************   ListRule    ********************/

RetType* ListRule::accept(Visitor *v) {
    return v->visitListRule(this);
}


ListRule *ListRule::clone() const
{
  return new ListRule(*this);
}


/********************   ListExpr    ********************/

RetType* ListExpr::accept(Visitor *v) {
    return v->visitListExpr(this);
}


ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}




