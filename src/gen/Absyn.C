//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   RSet    ********************/
RSet::RSet(ListRule *p1)
{
  listrule_ = p1;

}

RSet::RSet(const RSet & other)
{
  listrule_ = other.listrule_->clone();

}

RSet &RSet::operator=(const RSet & other)
{
  RSet tmp(other);
  swap(tmp);
  return *this;
}

void RSet::swap(RSet & other)
{
  std::swap(listrule_, other.listrule_);

}

RSet::~RSet()
{
  delete(listrule_);

}

RetType* RSet::accept(Visitor *v) {
  return v->visitRSet(this);
}

RSet *RSet::clone() const
{
  return new RSet(*this);
}



/********************   RRule    ********************/
RRule::RRule(Tag *p1, Severity *p2, RuleCause *p3, ASTScope *p4, Explanation *p5, Expr *p6)
{
  tag_ = p1;
  severity_ = p2;
  rulecause_ = p3;
  astscope_ = p4;
  explanation_ = p5;
  expr_ = p6;

}

RRule::RRule(const RRule & other)
{
  tag_ = other.tag_->clone();
  severity_ = other.severity_->clone();
  rulecause_ = other.rulecause_->clone();
  astscope_ = other.astscope_->clone();
  explanation_ = other.explanation_->clone();
  expr_ = other.expr_->clone();

}

RRule &RRule::operator=(const RRule & other)
{
  RRule tmp(other);
  swap(tmp);
  return *this;
}

void RRule::swap(RRule & other)
{
  std::swap(tag_, other.tag_);
  std::swap(severity_, other.severity_);
  std::swap(rulecause_, other.rulecause_);
  std::swap(astscope_, other.astscope_);
  std::swap(explanation_, other.explanation_);
  std::swap(expr_, other.expr_);

}

RRule::~RRule()
{
  delete(tag_);
  delete(severity_);
  delete(rulecause_);
  delete(astscope_);
  delete(explanation_);
  delete(expr_);

}

RetType* RRule::accept(Visitor *v) {
  return v->visitRRule(this);
}

RRule *RRule::clone() const
{
  return new RRule(*this);
}



/********************   ASTGlobally    ********************/
ASTGlobally::ASTGlobally()
{

}

ASTGlobally::ASTGlobally(const ASTGlobally & other)
{

}

ASTGlobally &ASTGlobally::operator=(const ASTGlobally & other)
{
  ASTGlobally tmp(other);
  swap(tmp);
  return *this;
}

void ASTGlobally::swap(ASTGlobally & other)
{

}

ASTGlobally::~ASTGlobally()
{

}

RetType* ASTGlobally::accept(Visitor *v) {
    return v->visitASTGlobally(this);
}

ASTGlobally *ASTGlobally::clone() const
{
  return new ASTGlobally(*this);
}



/********************   ASTFile    ********************/
ASTFile::ASTFile()
{

}

ASTFile::ASTFile(const ASTFile & other)
{

}

ASTFile &ASTFile::operator=(const ASTFile & other)
{
  ASTFile tmp(other);
  swap(tmp);
  return *this;
}

void ASTFile::swap(ASTFile & other)
{

}

ASTFile::~ASTFile()
{

}

RetType* ASTFile::accept(Visitor *v) {
    return v->visitASTFile(this);
}

ASTFile *ASTFile::clone() const
{
  return new ASTFile(*this);
}



/********************   ASTImported    ********************/
ASTImported::ASTImported()
{

}

ASTImported::ASTImported(const ASTImported & other)
{

}

ASTImported &ASTImported::operator=(const ASTImported & other)
{
  ASTImported tmp(other);
  swap(tmp);
  return *this;
}

void ASTImported::swap(ASTImported & other)
{

}

ASTImported::~ASTImported()
{

}

RetType* ASTImported::accept(Visitor *v) {
    return v->visitASTImported(this);
}

ASTImported *ASTImported::clone() const
{
  return new ASTImported(*this);
}



/********************   RCLang    ********************/
RCLang::RCLang()
{

}

RCLang::RCLang(const RCLang & other)
{

}

RCLang &RCLang::operator=(const RCLang & other)
{
  RCLang tmp(other);
  swap(tmp);
  return *this;
}

void RCLang::swap(RCLang & other)
{

}

RCLang::~RCLang()
{

}

RetType* RCLang::accept(Visitor *v) {
    return v->visitRCLang(this);
}

RCLang *RCLang::clone() const
{
  return new RCLang(*this);
}



/********************   RCPolicy    ********************/
RCPolicy::RCPolicy()
{

}

RCPolicy::RCPolicy(const RCPolicy & other)
{

}

RCPolicy &RCPolicy::operator=(const RCPolicy & other)
{
  RCPolicy tmp(other);
  swap(tmp);
  return *this;
}

void RCPolicy::swap(RCPolicy & other)
{

}

RCPolicy::~RCPolicy()
{

}

RetType* RCPolicy::accept(Visitor *v) {
    return v->visitRCPolicy(this);
}

RCPolicy *RCPolicy::clone() const
{
  return new RCPolicy(*this);
}



/********************   Explan    ********************/
Explan::Explan(String p1)
{
  string_ = p1;

}

Explan::Explan(const Explan & other)
{
  string_ = other.string_;

}

Explan &Explan::operator=(const Explan & other)
{
  Explan tmp(other);
  swap(tmp);
  return *this;
}

void Explan::swap(Explan & other)
{
  std::swap(string_, other.string_);

}

Explan::~Explan()
{

}

RetType* Explan::accept(Visitor *v) {
    return v->visitExplan(this);
}

Explan *Explan::clone() const
{
  return new Explan(*this);
}



/********************   Noexplan    ********************/
Noexplan::Noexplan()
{

}

Noexplan::Noexplan(const Noexplan & other)
{

}

Noexplan &Noexplan::operator=(const Noexplan & other)
{
  Noexplan tmp(other);
  swap(tmp);
  return *this;
}

void Noexplan::swap(Noexplan & other)
{

}

Noexplan::~Noexplan()
{

}

RetType* Noexplan::accept(Visitor *v) {
    return v->visitNoexplan(this);
}

Noexplan *Noexplan::clone() const
{
  return new Noexplan(*this);
}



/********************   TTag    ********************/
TTag::TTag(String p1)
{
  string_ = p1;

}

TTag::TTag(const TTag & other)
{
  string_ = other.string_;

}

TTag &TTag::operator=(const TTag & other)
{
  TTag tmp(other);
  swap(tmp);
  return *this;
}

void TTag::swap(TTag & other)
{
  std::swap(string_, other.string_);

}

TTag::~TTag()
{

}

RetType* TTag::accept(Visitor *v) {
    return v->visitTTag(this);
}

TTag *TTag::clone() const
{
  return new TTag(*this);
}



/********************   SevWarning    ********************/
SevWarning::SevWarning()
{

}

SevWarning::SevWarning(const SevWarning & other)
{

}

SevWarning &SevWarning::operator=(const SevWarning & other)
{
  SevWarning tmp(other);
  swap(tmp);
  return *this;
}

void SevWarning::swap(SevWarning & other)
{

}

SevWarning::~SevWarning()
{

}

RetType* SevWarning::accept(Visitor *v) {
    return v->visitSevWarning(this);
}

SevWarning *SevWarning::clone() const
{
  return new SevWarning(*this);
}



/********************   SevCritical    ********************/
SevCritical::SevCritical()
{

}

SevCritical::SevCritical(const SevCritical & other)
{

}

SevCritical &SevCritical::operator=(const SevCritical & other)
{
  SevCritical tmp(other);
  swap(tmp);
  return *this;
}

void SevCritical::swap(SevCritical & other)
{

}

SevCritical::~SevCritical()
{

}

RetType* SevCritical::accept(Visitor *v) {
    return v->visitSevCritical(this);
}

SevCritical *SevCritical::clone() const
{
  return new SevCritical(*this);
}



/********************   AG    ********************/
AG::AG(Expr *p1)
{
  expr_ = p1;

}

AG::AG(const AG & other)
{
  expr_ = other.expr_->clone();

}

AG &AG::operator=(const AG & other)
{
  AG tmp(other);
  swap(tmp);
  return *this;
}

void AG::swap(AG & other)
{
  std::swap(expr_, other.expr_);

}

AG::~AG()
{
  delete(expr_);

}

RetType* AG::accept(Visitor *v)
{
  v->visitAG(this);
}

AG *AG::clone() const
{
  return new AG(*this);
}



/********************   AF    ********************/
AF::AF(Expr *p1)
{
  expr_ = p1;

}

AF::AF(const AF & other)
{
  expr_ = other.expr_->clone();

}

AF &AF::operator=(const AF & other)
{
  AF tmp(other);
  swap(tmp);
  return *this;
}

void AF::swap(AF & other)
{
  std::swap(expr_, other.expr_);

}

AF::~AF()
{
  delete(expr_);

}

RetType* AF::accept(Visitor *v)
{
  v->visitAF(this);
}

AF *AF::clone() const
{
  return new AF(*this);
}



/********************   AX    ********************/
AX::AX(Expr *p1)
{
  expr_ = p1;

}

AX::AX(const AX & other)
{
  expr_ = other.expr_->clone();

}

AX &AX::operator=(const AX & other)
{
  AX tmp(other);
  swap(tmp);
  return *this;
}

void AX::swap(AX & other)
{
  std::swap(expr_, other.expr_);

}

AX::~AX()
{
  delete(expr_);

}

RetType* AX::accept(Visitor *v)
{
  v->visitAX(this);
}

AX *AX::clone() const
{
  return new AX(*this);
}



/********************   AU    ********************/
AU::AU(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

AU::AU(const AU & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

AU &AU::operator=(const AU & other)
{
  AU tmp(other);
  swap(tmp);
  return *this;
}

void AU::swap(AU & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

AU::~AU()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* AU::accept(Visitor *v)
{
  v->visitAU(this);
}

AU *AU::clone() const
{
  return new AU(*this);
}



/********************   EG    ********************/
EG::EG(Expr *p1)
{
  expr_ = p1;

}

EG::EG(const EG & other)
{
  expr_ = other.expr_->clone();

}

EG &EG::operator=(const EG & other)
{
  EG tmp(other);
  swap(tmp);
  return *this;
}

void EG::swap(EG & other)
{
  std::swap(expr_, other.expr_);

}

EG::~EG()
{
  delete(expr_);

}

RetType* EG::accept(Visitor *v)
{
  v->visitEG(this);
}

EG *EG::clone() const
{
  return new EG(*this);
}



/********************   EF    ********************/
EF::EF(Expr *p1)
{
  expr_ = p1;

}

EF::EF(const EF & other)
{
  expr_ = other.expr_->clone();

}

EF &EF::operator=(const EF & other)
{
  EF tmp(other);
  swap(tmp);
  return *this;
}

void EF::swap(EF & other)
{
  std::swap(expr_, other.expr_);

}

EF::~EF()
{
  delete(expr_);

}

RetType* EF::accept(Visitor *v)
{
  v->visitEF(this);
}

EF *EF::clone() const
{
  return new EF(*this);
}



/********************   EX    ********************/
EX::EX(Expr *p1)
{
  expr_ = p1;

}

EX::EX(const EX & other)
{
  expr_ = other.expr_->clone();

}

EX &EX::operator=(const EX & other)
{
  EX tmp(other);
  swap(tmp);
  return *this;
}

void EX::swap(EX & other)
{
  std::swap(expr_, other.expr_);

}

EX::~EX()
{
  delete(expr_);

}

RetType* EX::accept(Visitor *v)
{
  v->visitEX(this);
}

EX *EX::clone() const
{
  return new EX(*this);
}



/********************   EU    ********************/
EU::EU(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EU::EU(const EU & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EU &EU::operator=(const EU & other)
{
  EU tmp(other);
  swap(tmp);
  return *this;
}

void EU::swap(EU & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EU::~EU()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EU::accept(Visitor *v)
{
  v->visitEU(this);
}

EU *EU::clone() const
{
  return new EU(*this);
}



/********************   IEInt    ********************/
IEInt::IEInt(Integer p1)
{
  integer_ = p1;

}

IEInt::IEInt(const IEInt & other)
{
  integer_ = other.integer_;

}

IEInt &IEInt::operator=(const IEInt & other)
{
  IEInt tmp(other);
  swap(tmp);
  return *this;
}

void IEInt::swap(IEInt & other)
{
  std::swap(integer_, other.integer_);

}

IEInt::~IEInt()
{

}

RetType* IEInt::accept(Visitor *v) {
    return v->visitIEInt(this);
}

IEInt *IEInt::clone() const
{
  return new IEInt(*this);
}



/********************   IENrChildren    ********************/
IENrChildren::IENrChildren()
{

}

IENrChildren::IENrChildren(const IENrChildren & other)
{

}

IENrChildren &IENrChildren::operator=(const IENrChildren & other)
{
  IENrChildren tmp(other);
  swap(tmp);
  return *this;
}

void IENrChildren::swap(IENrChildren & other)
{

}

IENrChildren::~IENrChildren()
{

}

RetType* IENrChildren::accept(Visitor *v) {
    return v->visitIENrChildren(this);
}

IENrChildren *IENrChildren::clone() const
{
  return new IENrChildren(*this);
}



/********************   IERow    ********************/
IERow::IERow()
{

}

IERow::IERow(const IERow & other)
{

}

IERow &IERow::operator=(const IERow & other)
{
  IERow tmp(other);
  swap(tmp);
  return *this;
}

void IERow::swap(IERow & other)
{

}

IERow::~IERow()
{

}

RetType* IERow::accept(Visitor *v)
{
  v->visitIERow(this);
}

IERow *IERow::clone() const
{
  return new IERow(*this);
}



/********************   IECol    ********************/
IECol::IECol()
{

}

IECol::IECol(const IECol & other)
{

}

IECol &IECol::operator=(const IECol & other)
{
  IECol tmp(other);
  swap(tmp);
  return *this;
}

void IECol::swap(IECol & other)
{

}

IECol::~IECol()
{

}

RetType* IECol::accept(Visitor *v)
{
  v->visitIECol(this);
}

IECol *IECol::clone() const
{
  return new IECol(*this);
}



/********************   IELtEq    ********************/
IELtEq::IELtEq(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IELtEq::IELtEq(const IELtEq & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IELtEq &IELtEq::operator=(const IELtEq & other)
{
  IELtEq tmp(other);
  swap(tmp);
  return *this;
}

void IELtEq::swap(IELtEq & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IELtEq::~IELtEq()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IELtEq::accept(Visitor *v) {
    return v->visitIELtEq(this);
}

IELtEq *IELtEq::clone() const
{
  return new IELtEq(*this);
}



/********************   IEGtEq    ********************/
IEGtEq::IEGtEq(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IEGtEq::IEGtEq(const IEGtEq & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IEGtEq &IEGtEq::operator=(const IEGtEq & other)
{
  IEGtEq tmp(other);
  swap(tmp);
  return *this;
}

void IEGtEq::swap(IEGtEq & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IEGtEq::~IEGtEq()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IEGtEq::accept(Visitor *v) {
    return v->visitIEGtEq(this);
}

IEGtEq *IEGtEq::clone() const
{
  return new IEGtEq(*this);
}



/********************   IELt    ********************/
IELt::IELt(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IELt::IELt(const IELt & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IELt &IELt::operator=(const IELt & other)
{
  IELt tmp(other);
  swap(tmp);
  return *this;
}

void IELt::swap(IELt & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IELt::~IELt()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IELt::accept(Visitor *v) {
    return v->visitIELt(this);
}

IELt *IELt::clone() const
{
  return new IELt(*this);
}



/********************   IEGt    ********************/
IEGt::IEGt(IExpr *p1, IStmnt *p2)
{
  iexpr_ = p1;
  istmnt_ = p2;

}

IEGt::IEGt(const IEGt & other)
{
  iexpr_ = other.iexpr_->clone();
  istmnt_ = other.istmnt_->clone();

}

IEGt &IEGt::operator=(const IEGt & other)
{
  IEGt tmp(other);
  swap(tmp);
  return *this;
}

void IEGt::swap(IEGt & other)
{
  std::swap(iexpr_, other.iexpr_);
  std::swap(istmnt_, other.istmnt_);

}

IEGt::~IEGt()
{
  delete(iexpr_);
  delete(istmnt_);

}

RetType* IEGt::accept(Visitor *v) {
    return v->visitIEGt(this);
}

IEGt *IEGt::clone() const
{
  return new IEGt(*this);
}



/********************   IEq    ********************/
IEq::IEq(IStmnt *p1, IStmnt *p2)
{
  istmnt_1 = p1;
  istmnt_2 = p2;

}

IEq::IEq(const IEq & other)
{
  istmnt_1 = other.istmnt_1->clone();
  istmnt_2 = other.istmnt_2->clone();

}

IEq &IEq::operator=(const IEq & other)
{
  IEq tmp(other);
  swap(tmp);
  return *this;
}

void IEq::swap(IEq & other)
{
  std::swap(istmnt_1, other.istmnt_1);
  std::swap(istmnt_2, other.istmnt_2);

}

IEq::~IEq()
{
  delete(istmnt_1);
  delete(istmnt_2);

}

RetType* IEq::accept(Visitor *v) {
    return v->visitIEq(this);
}

IEq *IEq::clone() const
{
  return new IEq(*this);
}



/********************   IEStmnt    ********************/
IEStmnt::IEStmnt(IStmnt *p1)
{
  istmnt_ = p1;

}

IEStmnt::IEStmnt(const IEStmnt & other)
{
  istmnt_ = other.istmnt_->clone();

}

IEStmnt &IEStmnt::operator=(const IEStmnt & other)
{
  IEStmnt tmp(other);
  swap(tmp);
  return *this;
}

void IEStmnt::swap(IEStmnt & other)
{
  std::swap(istmnt_, other.istmnt_);

}

IEStmnt::~IEStmnt()
{
  delete(istmnt_);

}

RetType* IEStmnt::accept(Visitor *v) {
    return v->visitIEStmnt(this);
}

IEStmnt *IEStmnt::clone() const
{
  return new IEStmnt(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

RetType* ETrue::accept(Visitor *v) {
    return v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

RetType* EFalse::accept(Visitor *v) {
    return v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   EValue    ********************/
EValue::EValue(String p1)
{
  string_ = p1;

}

EValue::EValue(const EValue & other)
{
  string_ = other.string_;

}

EValue &EValue::operator=(const EValue & other)
{
  EValue tmp(other);
  swap(tmp);
  return *this;
}

void EValue::swap(EValue & other)
{
  std::swap(string_, other.string_);

}

EValue::~EValue()
{

}

RetType* EValue::accept(Visitor *v)
{
  v->visitEValue(this);
}

EValue *EValue::clone() const
{
  return new EValue(*this);
}



/********************   EValueType    ********************/
EValueType::EValueType(String p1)
{
  string_ = p1;

}

EValueType::EValueType(const EValueType & other)
{
  string_ = other.string_;

}

EValueType &EValueType::operator=(const EValueType & other)
{
  EValueType tmp(other);
  swap(tmp);
  return *this;
}

void EValueType::swap(EValueType & other)
{
  std::swap(string_, other.string_);

}

EValueType::~EValueType()
{

}

RetType* EValueType::accept(Visitor *v)
{
  v->visitEValueType(this);
}

EValueType *EValueType::clone() const
{
  return new EValueType(*this);
}



/********************   ENodeType    ********************/
ENodeType::ENodeType(String p1)
{
  string_ = p1;

}

ENodeType::ENodeType(const ENodeType & other)
{
  string_ = other.string_;

}

ENodeType &ENodeType::operator=(const ENodeType & other)
{
  ENodeType tmp(other);
  swap(tmp);
  return *this;
}

void ENodeType::swap(ENodeType & other)
{
  std::swap(string_, other.string_);

}

ENodeType::~ENodeType()
{

}

RetType* ENodeType::accept(Visitor *v)
{
  v->visitENodeType(this);
}

ENodeType *ENodeType::clone() const
{
  return new ENodeType(*this);
}



/********************   EParant    ********************/
EParant::EParant(Expr *p1)
{
  expr_ = p1;

}

EParant::EParant(const EParant & other)
{
  expr_ = other.expr_->clone();

}

EParant &EParant::operator=(const EParant & other)
{
  EParant tmp(other);
  swap(tmp);
  return *this;
}

void EParant::swap(EParant & other)
{
  std::swap(expr_, other.expr_);

}

EParant::~EParant()
{
  delete(expr_);

}

RetType* EParant::accept(Visitor *v) {
    return v->visitEParant(this);
}

EParant *EParant::clone() const
{
  return new EParant(*this);
}



/********************   ENot    ********************/
ENot::ENot(Expr *p1)
{
  expr_ = p1;

}

ENot::ENot(const ENot & other)
{
  expr_ = other.expr_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(expr_, other.expr_);

}

ENot::~ENot()
{
  delete(expr_);

}

RetType* ENot::accept(Visitor *v) {
    return v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}



/********************   EImpl    ********************/
EImpl::EImpl(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EImpl::EImpl(const EImpl & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EImpl &EImpl::operator=(const EImpl & other)
{
  EImpl tmp(other);
  swap(tmp);
  return *this;
}

void EImpl::swap(EImpl & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EImpl::~EImpl()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EImpl::accept(Visitor *v) {
    return v->visitEImpl(this);
}

EImpl *EImpl::clone() const
{
  return new EImpl(*this);
}



/********************   EIExpr    ********************/
EIExpr::EIExpr(IExpr *p1)
{
  iexpr_ = p1;

}

EIExpr::EIExpr(const EIExpr & other)
{
  iexpr_ = other.iexpr_->clone();

}

EIExpr &EIExpr::operator=(const EIExpr & other)
{
  EIExpr tmp(other);
  swap(tmp);
  return *this;
}

void EIExpr::swap(EIExpr & other)
{
  std::swap(iexpr_, other.iexpr_);

}

EIExpr::~EIExpr()
{
  delete(iexpr_);

}

RetType* EIExpr::accept(Visitor *v) {
    return v->visitEIExpr(this);
}

EIExpr *EIExpr::clone() const
{
  return new EIExpr(*this);
}



/********************   EEq    ********************/
EEq::EEq(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EEq::EEq(const EEq & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EEq &EEq::operator=(const EEq & other)
{
  EEq tmp(other);
  swap(tmp);
  return *this;
}

void EEq::swap(EEq & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EEq::~EEq()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EEq::accept(Visitor *v) {
    return v->visitEEq(this);
}

EEq *EEq::clone() const
{
  return new EEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EAnd::accept(Visitor *v) {
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

RetType* EOr::accept(Visitor *v) {
    return v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EPQ    ********************/
EPQ::EPQ(PathQuantifier *p1)
{
  pathquantifier_ = p1;

}

EPQ::EPQ(const EPQ & other)
{
  pathquantifier_ = other.pathquantifier_->clone();

}

EPQ &EPQ::operator=(const EPQ & other)
{
  EPQ tmp(other);
  swap(tmp);
  return *this;
}

void EPQ::swap(EPQ & other)
{
  std::swap(pathquantifier_, other.pathquantifier_);

}

EPQ::~EPQ()
{
  delete(pathquantifier_);

}

RetType* EPQ::accept(Visitor *v)
{
  v->visitEPQ(this);
}

EPQ *EPQ::clone() const
{
  return new EPQ(*this);
}




/********************   ListRule    ********************/

RetType* ListRule::accept(Visitor *v) {
    return v->visitListRule(this);
}


ListRule *ListRule::clone() const
{
  return new ListRule(*this);
}


/********************   ListExpr    ********************/

RetType* ListExpr::accept(Visitor *v) {
    return v->visitListExpr(this);
}


ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}




