// Copyright (C) 2016 Pelagicore
//
// You may use this file under the terms of the GPLv3 license.
// See the file LICENSE from this package for details.
//
// SPDX-License-Identifier: GPL-3.0
//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.H"

/********************   RSet    ********************/
RSet::RSet(ListRule *p1)
{
  listrule_ = p1;

}

RSet::RSet(const RSet & other)
{
  listrule_ = other.listrule_->clone();

}

RSet &RSet::operator=(const RSet & other)
{
  RSet tmp(other);
  swap(tmp);
  return *this;
}

void RSet::swap(RSet & other)
{
  std::swap(listrule_, other.listrule_);

}

RSet::~RSet()
{
  delete(listrule_);

}

QPointer<RetType> RSet::accept(Visitor *v)
{
  return v->visitRSet(this);
}

RSet *RSet::clone() const
{
  return new RSet(*this);
}



/********************   RRule    ********************/
RRule::RRule(Tag *p1, Severity *p2, RuleCause *p3, ASTScope *p4, Explanation *p5, Quantifier *p6)
{
  tag_ = p1;
  severity_ = p2;
  rulecause_ = p3;
  astscope_ = p4;
  explanation_ = p5;
  quantifier_ = p6;

}

RRule::RRule(const RRule & other)
{
  tag_ = other.tag_->clone();
  severity_ = other.severity_->clone();
  rulecause_ = other.rulecause_->clone();
  astscope_ = other.astscope_->clone();
  explanation_ = other.explanation_->clone();
  quantifier_ = other.quantifier_->clone();

}

RRule &RRule::operator=(const RRule & other)
{
  RRule tmp(other);
  swap(tmp);
  return *this;
}

void RRule::swap(RRule & other)
{
  std::swap(tag_, other.tag_);
  std::swap(severity_, other.severity_);
  std::swap(rulecause_, other.rulecause_);
  std::swap(astscope_, other.astscope_);
  std::swap(explanation_, other.explanation_);
  std::swap(quantifier_, other.quantifier_);

}

RRule::~RRule()
{
  delete(tag_);
  delete(severity_);
  delete(rulecause_);
  delete(astscope_);
  delete(explanation_);
  delete(quantifier_);

}

QPointer<RetType> RRule::accept(Visitor *v)
{
  return v->visitRRule(this);
}

RRule *RRule::clone() const
{
  return new RRule(*this);
}



/********************   ASTGlobally    ********************/
ASTGlobally::ASTGlobally()
{

}

ASTGlobally::ASTGlobally(const ASTGlobally & other)
{

}

ASTGlobally &ASTGlobally::operator=(const ASTGlobally & other)
{
  ASTGlobally tmp(other);
  swap(tmp);
  return *this;
}

void ASTGlobally::swap(ASTGlobally & other)
{

}

ASTGlobally::~ASTGlobally()
{

}

QPointer<RetType> ASTGlobally::accept(Visitor *v)
{
  return v->visitASTGlobally(this);
}

ASTGlobally *ASTGlobally::clone() const
{
  return new ASTGlobally(*this);
}



/********************   ASTFile    ********************/
ASTFile::ASTFile()
{

}

ASTFile::ASTFile(const ASTFile & other)
{

}

ASTFile &ASTFile::operator=(const ASTFile & other)
{
  ASTFile tmp(other);
  swap(tmp);
  return *this;
}

void ASTFile::swap(ASTFile & other)
{

}

ASTFile::~ASTFile()
{

}

QPointer<RetType> ASTFile::accept(Visitor *v)
{
  return v->visitASTFile(this);
}

ASTFile *ASTFile::clone() const
{
  return new ASTFile(*this);
}



/********************   ASTImported    ********************/
ASTImported::ASTImported()
{

}

ASTImported::ASTImported(const ASTImported & other)
{

}

ASTImported &ASTImported::operator=(const ASTImported & other)
{
  ASTImported tmp(other);
  swap(tmp);
  return *this;
}

void ASTImported::swap(ASTImported & other)
{

}

ASTImported::~ASTImported()
{

}

QPointer<RetType> ASTImported::accept(Visitor *v)
{
  return v->visitASTImported(this);
}

ASTImported *ASTImported::clone() const
{
  return new ASTImported(*this);
}



/********************   RCLang    ********************/
RCLang::RCLang()
{

}

RCLang::RCLang(const RCLang & other)
{

}

RCLang &RCLang::operator=(const RCLang & other)
{
  RCLang tmp(other);
  swap(tmp);
  return *this;
}

void RCLang::swap(RCLang & other)
{

}

RCLang::~RCLang()
{

}

QPointer<RetType> RCLang::accept(Visitor *v)
{
  return v->visitRCLang(this);
}

RCLang *RCLang::clone() const
{
  return new RCLang(*this);
}



/********************   RCPolicy    ********************/
RCPolicy::RCPolicy()
{

}

RCPolicy::RCPolicy(const RCPolicy & other)
{

}

RCPolicy &RCPolicy::operator=(const RCPolicy & other)
{
  RCPolicy tmp(other);
  swap(tmp);
  return *this;
}

void RCPolicy::swap(RCPolicy & other)
{

}

RCPolicy::~RCPolicy()
{

}

QPointer<RetType> RCPolicy::accept(Visitor *v)
{
  return v->visitRCPolicy(this);
}

RCPolicy *RCPolicy::clone() const
{
  return new RCPolicy(*this);
}



/********************   Explan    ********************/
Explan::Explan(String p1)
{
  string_ = p1;

}

Explan::Explan(const Explan & other)
{
  string_ = other.string_;

}

Explan &Explan::operator=(const Explan & other)
{
  Explan tmp(other);
  swap(tmp);
  return *this;
}

void Explan::swap(Explan & other)
{
  std::swap(string_, other.string_);

}

Explan::~Explan()
{

}

QPointer<RetType> Explan::accept(Visitor *v)
{
  return v->visitExplan(this);
}

Explan *Explan::clone() const
{
  return new Explan(*this);
}



/********************   Noexplan    ********************/
Noexplan::Noexplan()
{

}

Noexplan::Noexplan(const Noexplan & other)
{

}

Noexplan &Noexplan::operator=(const Noexplan & other)
{
  Noexplan tmp(other);
  swap(tmp);
  return *this;
}

void Noexplan::swap(Noexplan & other)
{

}

Noexplan::~Noexplan()
{

}

QPointer<RetType> Noexplan::accept(Visitor *v)
{
  return v->visitNoexplan(this);
}

Noexplan *Noexplan::clone() const
{
  return new Noexplan(*this);
}



/********************   TTag    ********************/
TTag::TTag(String p1)
{
  string_ = p1;

}

TTag::TTag(const TTag & other)
{
  string_ = other.string_;

}

TTag &TTag::operator=(const TTag & other)
{
  TTag tmp(other);
  swap(tmp);
  return *this;
}

void TTag::swap(TTag & other)
{
  std::swap(string_, other.string_);

}

TTag::~TTag()
{

}

QPointer<RetType> TTag::accept(Visitor *v)
{
  return v->visitTTag(this);
}

TTag *TTag::clone() const
{
  return new TTag(*this);
}



/********************   SevInfo    ********************/
SevInfo::SevInfo()
{

}

SevInfo::SevInfo(const SevInfo & other)
{

}

SevInfo &SevInfo::operator=(const SevInfo & other)
{
  SevInfo tmp(other);
  swap(tmp);
  return *this;
}

void SevInfo::swap(SevInfo & other)
{

}

SevInfo::~SevInfo()
{

}

QPointer<RetType> SevInfo::accept(Visitor *v)
{
  return v->visitSevInfo(this);
}

SevInfo *SevInfo::clone() const
{
  return new SevInfo(*this);
}



/********************   SevWarning    ********************/
SevWarning::SevWarning()
{

}

SevWarning::SevWarning(const SevWarning & other)
{

}

SevWarning &SevWarning::operator=(const SevWarning & other)
{
  SevWarning tmp(other);
  swap(tmp);
  return *this;
}

void SevWarning::swap(SevWarning & other)
{

}

SevWarning::~SevWarning()
{

}

QPointer<RetType> SevWarning::accept(Visitor *v)
{
  return v->visitSevWarning(this);
}

SevWarning *SevWarning::clone() const
{
  return new SevWarning(*this);
}



/********************   SevCritical    ********************/
SevCritical::SevCritical()
{

}

SevCritical::SevCritical(const SevCritical & other)
{

}

SevCritical &SevCritical::operator=(const SevCritical & other)
{
  SevCritical tmp(other);
  swap(tmp);
  return *this;
}

void SevCritical::swap(SevCritical & other)
{

}

SevCritical::~SevCritical()
{

}

QPointer<RetType> SevCritical::accept(Visitor *v)
{
  return v->visitSevCritical(this);
}

SevCritical *SevCritical::clone() const
{
  return new SevCritical(*this);
}



/********************   QExpr    ********************/
QExpr::QExpr(Expr *p1)
{
  expr_ = p1;

}

QExpr::QExpr(const QExpr & other)
{
  expr_ = other.expr_->clone();

}

QExpr &QExpr::operator=(const QExpr & other)
{
  QExpr tmp(other);
  swap(tmp);
  return *this;
}

void QExpr::swap(QExpr & other)
{
  std::swap(expr_, other.expr_);

}

QExpr::~QExpr()
{
  delete(expr_);

}

QPointer<RetType> QExpr::accept(Visitor *v)
{
  return v->visitQExpr(this);
}

QExpr *QExpr::clone() const
{
  return new QExpr(*this);
}



/********************   QFor    ********************/
QFor::QFor(String p1, Expr *p2)
{
  string_ = p1;
  expr_ = p2;

}

QFor::QFor(const QFor & other)
{
  string_ = other.string_;
  expr_ = other.expr_->clone();

}

QFor &QFor::operator=(const QFor & other)
{
  QFor tmp(other);
  swap(tmp);
  return *this;
}

void QFor::swap(QFor & other)
{
  std::swap(string_, other.string_);
  std::swap(expr_, other.expr_);

}

QFor::~QFor()
{
  delete(expr_);

}

QPointer<RetType> QFor::accept(Visitor *v)
{
  return v->visitQFor(this);
}

QFor *QFor::clone() const
{
  return new QFor(*this);
}



/********************   AG    ********************/
AG::AG(Expr *p1)
{
  expr_ = p1;

}

AG::AG(const AG & other)
{
  expr_ = other.expr_->clone();

}

AG &AG::operator=(const AG & other)
{
  AG tmp(other);
  swap(tmp);
  return *this;
}

void AG::swap(AG & other)
{
  std::swap(expr_, other.expr_);

}

AG::~AG()
{
  delete(expr_);

}

QPointer<RetType> AG::accept(Visitor *v)
{
  return v->visitAG(this);
}

AG *AG::clone() const
{
  return new AG(*this);
}



/********************   AF    ********************/
AF::AF(Expr *p1)
{
  expr_ = p1;

}

AF::AF(const AF & other)
{
  expr_ = other.expr_->clone();

}

AF &AF::operator=(const AF & other)
{
  AF tmp(other);
  swap(tmp);
  return *this;
}

void AF::swap(AF & other)
{
  std::swap(expr_, other.expr_);

}

AF::~AF()
{
  delete(expr_);

}

QPointer<RetType> AF::accept(Visitor *v)
{
  return v->visitAF(this);
}

AF *AF::clone() const
{
  return new AF(*this);
}



/********************   AX    ********************/
AX::AX(Expr *p1)
{
  expr_ = p1;

}

AX::AX(const AX & other)
{
  expr_ = other.expr_->clone();

}

AX &AX::operator=(const AX & other)
{
  AX tmp(other);
  swap(tmp);
  return *this;
}

void AX::swap(AX & other)
{
  std::swap(expr_, other.expr_);

}

AX::~AX()
{
  delete(expr_);

}

QPointer<RetType> AX::accept(Visitor *v)
{
  return v->visitAX(this);
}

AX *AX::clone() const
{
  return new AX(*this);
}



/********************   AU    ********************/
AU::AU(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

AU::AU(const AU & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

AU &AU::operator=(const AU & other)
{
  AU tmp(other);
  swap(tmp);
  return *this;
}

void AU::swap(AU & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

AU::~AU()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> AU::accept(Visitor *v)
{
  return v->visitAU(this);
}

AU *AU::clone() const
{
  return new AU(*this);
}



/********************   EG    ********************/
EG::EG(Expr *p1)
{
  expr_ = p1;

}

EG::EG(const EG & other)
{
  expr_ = other.expr_->clone();

}

EG &EG::operator=(const EG & other)
{
  EG tmp(other);
  swap(tmp);
  return *this;
}

void EG::swap(EG & other)
{
  std::swap(expr_, other.expr_);

}

EG::~EG()
{
  delete(expr_);

}

QPointer<RetType> EG::accept(Visitor *v)
{
  return v->visitEG(this);
}

EG *EG::clone() const
{
  return new EG(*this);
}



/********************   EF    ********************/
EF::EF(Expr *p1)
{
  expr_ = p1;

}

EF::EF(const EF & other)
{
  expr_ = other.expr_->clone();

}

EF &EF::operator=(const EF & other)
{
  EF tmp(other);
  swap(tmp);
  return *this;
}

void EF::swap(EF & other)
{
  std::swap(expr_, other.expr_);

}

EF::~EF()
{
  delete(expr_);

}

QPointer<RetType> EF::accept(Visitor *v)
{
  return v->visitEF(this);
}

EF *EF::clone() const
{
  return new EF(*this);
}



/********************   EX    ********************/
EX::EX(Expr *p1)
{
  expr_ = p1;

}

EX::EX(const EX & other)
{
  expr_ = other.expr_->clone();

}

EX &EX::operator=(const EX & other)
{
  EX tmp(other);
  swap(tmp);
  return *this;
}

void EX::swap(EX & other)
{
  std::swap(expr_, other.expr_);

}

EX::~EX()
{
  delete(expr_);

}

QPointer<RetType> EX::accept(Visitor *v)
{
  return v->visitEX(this);
}

EX *EX::clone() const
{
  return new EX(*this);
}



/********************   EU    ********************/
EU::EU(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EU::EU(const EU & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EU &EU::operator=(const EU & other)
{
  EU tmp(other);
  swap(tmp);
  return *this;
}

void EU::swap(EU & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EU::~EU()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> EU::accept(Visitor *v)
{
  return v->visitEU(this);
}

EU *EU::clone() const
{
  return new EU(*this);
}



/********************   IFRow    ********************/
IFRow::IFRow()
{

}

IFRow::IFRow(const IFRow & other)
{

}

IFRow &IFRow::operator=(const IFRow & other)
{
  IFRow tmp(other);
  swap(tmp);
  return *this;
}

void IFRow::swap(IFRow & other)
{

}

IFRow::~IFRow()
{

}

QPointer<RetType> IFRow::accept(Visitor *v)
{
  return v->visitIFRow(this);
}

IFRow *IFRow::clone() const
{
  return new IFRow(*this);
}



/********************   IFCol    ********************/
IFCol::IFCol()
{

}

IFCol::IFCol(const IFCol & other)
{

}

IFCol &IFCol::operator=(const IFCol & other)
{
  IFCol tmp(other);
  swap(tmp);
  return *this;
}

void IFCol::swap(IFCol & other)
{

}

IFCol::~IFCol()
{

}

QPointer<RetType> IFCol::accept(Visitor *v)
{
  return v->visitIFCol(this);
}

IFCol *IFCol::clone() const
{
  return new IFCol(*this);
}



/********************   IInt    ********************/
IInt::IInt(Integer p1)
{
  integer_ = p1;

}

IInt::IInt(const IInt & other)
{
  integer_ = other.integer_;

}

IInt &IInt::operator=(const IInt & other)
{
  IInt tmp(other);
  swap(tmp);
  return *this;
}

void IInt::swap(IInt & other)
{
  std::swap(integer_, other.integer_);

}

IInt::~IInt()
{

}

QPointer<RetType> IInt::accept(Visitor *v)
{
  return v->visitIInt(this);
}

IInt *IInt::clone() const
{
  return new IInt(*this);
}



/********************   INrChildren    ********************/
INrChildren::INrChildren()
{

}

INrChildren::INrChildren(const INrChildren & other)
{

}

INrChildren &INrChildren::operator=(const INrChildren & other)
{
  INrChildren tmp(other);
  swap(tmp);
  return *this;
}

void INrChildren::swap(INrChildren & other)
{

}

INrChildren::~INrChildren()
{

}

QPointer<RetType> INrChildren::accept(Visitor *v)
{
  return v->visitINrChildren(this);
}

INrChildren *INrChildren::clone() const
{
  return new INrChildren(*this);
}



/********************   IRow    ********************/
IRow::IRow()
{

}

IRow::IRow(const IRow & other)
{

}

IRow &IRow::operator=(const IRow & other)
{
  IRow tmp(other);
  swap(tmp);
  return *this;
}

void IRow::swap(IRow & other)
{

}

IRow::~IRow()
{

}

QPointer<RetType> IRow::accept(Visitor *v)
{
  return v->visitIRow(this);
}

IRow *IRow::clone() const
{
  return new IRow(*this);
}



/********************   ICol    ********************/
ICol::ICol()
{

}

ICol::ICol(const ICol & other)
{

}

ICol &ICol::operator=(const ICol & other)
{
  ICol tmp(other);
  swap(tmp);
  return *this;
}

void ICol::swap(ICol & other)
{

}

ICol::~ICol()
{

}

QPointer<RetType> ICol::accept(Visitor *v)
{
  return v->visitICol(this);
}

ICol *ICol::clone() const
{
  return new ICol(*this);
}



/********************   SString    ********************/
SString::SString(String p1)
{
  string_ = p1;

}

SString::SString(const SString & other)
{
  string_ = other.string_;

}

SString &SString::operator=(const SString & other)
{
  SString tmp(other);
  swap(tmp);
  return *this;
}

void SString::swap(SString & other)
{
  std::swap(string_, other.string_);

}

SString::~SString()
{

}

QPointer<RetType> SString::accept(Visitor *v)
{
  return v->visitSString(this);
}

SString *SString::clone() const
{
  return new SString(*this);
}



/********************   SFValue    ********************/
SFValue::SFValue()
{

}

SFValue::SFValue(const SFValue & other)
{

}

SFValue &SFValue::operator=(const SFValue & other)
{
  SFValue tmp(other);
  swap(tmp);
  return *this;
}

void SFValue::swap(SFValue & other)
{

}

SFValue::~SFValue()
{

}

QPointer<RetType> SFValue::accept(Visitor *v)
{
  return v->visitSFValue(this);
}

SFValue *SFValue::clone() const
{
  return new SFValue(*this);
}



/********************   SValue    ********************/
SValue::SValue()
{

}

SValue::SValue(const SValue & other)
{

}

SValue &SValue::operator=(const SValue & other)
{
  SValue tmp(other);
  swap(tmp);
  return *this;
}

void SValue::swap(SValue & other)
{

}

SValue::~SValue()
{

}

QPointer<RetType> SValue::accept(Visitor *v)
{
  return v->visitSValue(this);
}

SValue *SValue::clone() const
{
  return new SValue(*this);
}



/********************   SValueType    ********************/
SValueType::SValueType()
{

}

SValueType::SValueType(const SValueType & other)
{

}

SValueType &SValueType::operator=(const SValueType & other)
{
  SValueType tmp(other);
  swap(tmp);
  return *this;
}

void SValueType::swap(SValueType & other)
{

}

SValueType::~SValueType()
{

}

QPointer<RetType> SValueType::accept(Visitor *v)
{
  return v->visitSValueType(this);
}

SValueType *SValueType::clone() const
{
  return new SValueType(*this);
}



/********************   SNodeType    ********************/
SNodeType::SNodeType()
{

}

SNodeType::SNodeType(const SNodeType & other)
{

}

SNodeType &SNodeType::operator=(const SNodeType & other)
{
  SNodeType tmp(other);
  swap(tmp);
  return *this;
}

void SNodeType::swap(SNodeType & other)
{

}

SNodeType::~SNodeType()
{

}

QPointer<RetType> SNodeType::accept(Visitor *v)
{
  return v->visitSNodeType(this);
}

SNodeType *SNodeType::clone() const
{
  return new SNodeType(*this);
}



/********************   SConcat    ********************/
SConcat::SConcat(SAtom *p1, SAtom *p2)
{
  satom_1 = p1;
  satom_2 = p2;

}

SConcat::SConcat(const SConcat & other)
{
  satom_1 = other.satom_1->clone();
  satom_2 = other.satom_2->clone();

}

SConcat &SConcat::operator=(const SConcat & other)
{
  SConcat tmp(other);
  swap(tmp);
  return *this;
}

void SConcat::swap(SConcat & other)
{
  std::swap(satom_1, other.satom_1);
  std::swap(satom_2, other.satom_2);

}

SConcat::~SConcat()
{
  delete(satom_1);
  delete(satom_2);

}

QPointer<RetType> SConcat::accept(Visitor *v)
{
  return v->visitSConcat(this);
}

SConcat *SConcat::clone() const
{
  return new SConcat(*this);
}



/********************   ETrue    ********************/
ETrue::ETrue()
{

}

ETrue::ETrue(const ETrue & other)
{

}

ETrue &ETrue::operator=(const ETrue & other)
{
  ETrue tmp(other);
  swap(tmp);
  return *this;
}

void ETrue::swap(ETrue & other)
{

}

ETrue::~ETrue()
{

}

QPointer<RetType> ETrue::accept(Visitor *v)
{
  return v->visitETrue(this);
}

ETrue *ETrue::clone() const
{
  return new ETrue(*this);
}



/********************   EFalse    ********************/
EFalse::EFalse()
{

}

EFalse::EFalse(const EFalse & other)
{

}

EFalse &EFalse::operator=(const EFalse & other)
{
  EFalse tmp(other);
  swap(tmp);
  return *this;
}

void EFalse::swap(EFalse & other)
{

}

EFalse::~EFalse()
{

}

QPointer<RetType> EFalse::accept(Visitor *v)
{
  return v->visitEFalse(this);
}

EFalse *EFalse::clone() const
{
  return new EFalse(*this);
}



/********************   EParant    ********************/
EParant::EParant(Expr *p1)
{
  expr_ = p1;

}

EParant::EParant(const EParant & other)
{
  expr_ = other.expr_->clone();

}

EParant &EParant::operator=(const EParant & other)
{
  EParant tmp(other);
  swap(tmp);
  return *this;
}

void EParant::swap(EParant & other)
{
  std::swap(expr_, other.expr_);

}

EParant::~EParant()
{
  delete(expr_);

}

QPointer<RetType> EParant::accept(Visitor *v)
{
  return v->visitEParant(this);
}

EParant *EParant::clone() const
{
  return new EParant(*this);
}



/********************   ENot    ********************/
ENot::ENot(Expr *p1)
{
  expr_ = p1;

}

ENot::ENot(const ENot & other)
{
  expr_ = other.expr_->clone();

}

ENot &ENot::operator=(const ENot & other)
{
  ENot tmp(other);
  swap(tmp);
  return *this;
}

void ENot::swap(ENot & other)
{
  std::swap(expr_, other.expr_);

}

ENot::~ENot()
{
  delete(expr_);

}

QPointer<RetType> ENot::accept(Visitor *v)
{
  return v->visitENot(this);
}

ENot *ENot::clone() const
{
  return new ENot(*this);
}



/********************   EImpl    ********************/
EImpl::EImpl(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EImpl::EImpl(const EImpl & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EImpl &EImpl::operator=(const EImpl & other)
{
  EImpl tmp(other);
  swap(tmp);
  return *this;
}

void EImpl::swap(EImpl & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EImpl::~EImpl()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> EImpl::accept(Visitor *v)
{
  return v->visitEImpl(this);
}

EImpl *EImpl::clone() const
{
  return new EImpl(*this);
}



/********************   EBEq    ********************/
EBEq::EBEq(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EBEq::EBEq(const EBEq & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EBEq &EBEq::operator=(const EBEq & other)
{
  EBEq tmp(other);
  swap(tmp);
  return *this;
}

void EBEq::swap(EBEq & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EBEq::~EBEq()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> EBEq::accept(Visitor *v)
{
  return v->visitEBEq(this);
}

EBEq *EBEq::clone() const
{
  return new EBEq(*this);
}



/********************   EPossToken    ********************/
EPossToken::EPossToken(String p1)
{
  string_ = p1;

}

EPossToken::EPossToken(const EPossToken & other)
{
  string_ = other.string_;

}

EPossToken &EPossToken::operator=(const EPossToken & other)
{
  EPossToken tmp(other);
  swap(tmp);
  return *this;
}

void EPossToken::swap(EPossToken & other)
{
  std::swap(string_, other.string_);

}

EPossToken::~EPossToken()
{

}

QPointer<RetType> EPossToken::accept(Visitor *v)
{
  return v->visitEPossToken(this);
}

EPossToken *EPossToken::clone() const
{
  return new EPossToken(*this);
}



/********************   EExistToken    ********************/
EExistToken::EExistToken(String p1)
{
  string_ = p1;

}

EExistToken::EExistToken(const EExistToken & other)
{
  string_ = other.string_;

}

EExistToken &EExistToken::operator=(const EExistToken & other)
{
  EExistToken tmp(other);
  swap(tmp);
  return *this;
}

void EExistToken::swap(EExistToken & other)
{
  std::swap(string_, other.string_);

}

EExistToken::~EExistToken()
{

}

QPointer<RetType> EExistToken::accept(Visitor *v)
{
  return v->visitEExistToken(this);
}

EExistToken *EExistToken::clone() const
{
  return new EExistToken(*this);
}



/********************   EILtEq    ********************/
EILtEq::EILtEq(IAtom *p1, IAtom *p2)
{
  iatom_1 = p1;
  iatom_2 = p2;

}

EILtEq::EILtEq(const EILtEq & other)
{
  iatom_1 = other.iatom_1->clone();
  iatom_2 = other.iatom_2->clone();

}

EILtEq &EILtEq::operator=(const EILtEq & other)
{
  EILtEq tmp(other);
  swap(tmp);
  return *this;
}

void EILtEq::swap(EILtEq & other)
{
  std::swap(iatom_1, other.iatom_1);
  std::swap(iatom_2, other.iatom_2);

}

EILtEq::~EILtEq()
{
  delete(iatom_1);
  delete(iatom_2);

}

QPointer<RetType> EILtEq::accept(Visitor *v)
{
  return v->visitEILtEq(this);
}

EILtEq *EILtEq::clone() const
{
  return new EILtEq(*this);
}



/********************   EIGtEq    ********************/
EIGtEq::EIGtEq(IAtom *p1, IAtom *p2)
{
  iatom_1 = p1;
  iatom_2 = p2;

}

EIGtEq::EIGtEq(const EIGtEq & other)
{
  iatom_1 = other.iatom_1->clone();
  iatom_2 = other.iatom_2->clone();

}

EIGtEq &EIGtEq::operator=(const EIGtEq & other)
{
  EIGtEq tmp(other);
  swap(tmp);
  return *this;
}

void EIGtEq::swap(EIGtEq & other)
{
  std::swap(iatom_1, other.iatom_1);
  std::swap(iatom_2, other.iatom_2);

}

EIGtEq::~EIGtEq()
{
  delete(iatom_1);
  delete(iatom_2);

}

QPointer<RetType> EIGtEq::accept(Visitor *v)
{
  return v->visitEIGtEq(this);
}

EIGtEq *EIGtEq::clone() const
{
  return new EIGtEq(*this);
}



/********************   EILt    ********************/
EILt::EILt(IAtom *p1, IAtom *p2)
{
  iatom_1 = p1;
  iatom_2 = p2;

}

EILt::EILt(const EILt & other)
{
  iatom_1 = other.iatom_1->clone();
  iatom_2 = other.iatom_2->clone();

}

EILt &EILt::operator=(const EILt & other)
{
  EILt tmp(other);
  swap(tmp);
  return *this;
}

void EILt::swap(EILt & other)
{
  std::swap(iatom_1, other.iatom_1);
  std::swap(iatom_2, other.iatom_2);

}

EILt::~EILt()
{
  delete(iatom_1);
  delete(iatom_2);

}

QPointer<RetType> EILt::accept(Visitor *v)
{
  return v->visitEILt(this);
}

EILt *EILt::clone() const
{
  return new EILt(*this);
}



/********************   EIGt    ********************/
EIGt::EIGt(IAtom *p1, IAtom *p2)
{
  iatom_1 = p1;
  iatom_2 = p2;

}

EIGt::EIGt(const EIGt & other)
{
  iatom_1 = other.iatom_1->clone();
  iatom_2 = other.iatom_2->clone();

}

EIGt &EIGt::operator=(const EIGt & other)
{
  EIGt tmp(other);
  swap(tmp);
  return *this;
}

void EIGt::swap(EIGt & other)
{
  std::swap(iatom_1, other.iatom_1);
  std::swap(iatom_2, other.iatom_2);

}

EIGt::~EIGt()
{
  delete(iatom_1);
  delete(iatom_2);

}

QPointer<RetType> EIGt::accept(Visitor *v)
{
  return v->visitEIGt(this);
}

EIGt *EIGt::clone() const
{
  return new EIGt(*this);
}



/********************   EIEq    ********************/
EIEq::EIEq(IAtom *p1, IAtom *p2)
{
  iatom_1 = p1;
  iatom_2 = p2;

}

EIEq::EIEq(const EIEq & other)
{
  iatom_1 = other.iatom_1->clone();
  iatom_2 = other.iatom_2->clone();

}

EIEq &EIEq::operator=(const EIEq & other)
{
  EIEq tmp(other);
  swap(tmp);
  return *this;
}

void EIEq::swap(EIEq & other)
{
  std::swap(iatom_1, other.iatom_1);
  std::swap(iatom_2, other.iatom_2);

}

EIEq::~EIEq()
{
  delete(iatom_1);
  delete(iatom_2);

}

QPointer<RetType> EIEq::accept(Visitor *v)
{
  return v->visitEIEq(this);
}

EIEq *EIEq::clone() const
{
  return new EIEq(*this);
}



/********************   EMatch    ********************/
EMatch::EMatch(SAtom *p1, String p2)
{
  satom_ = p1;
  string_ = p2;

}

EMatch::EMatch(const EMatch & other)
{
  satom_ = other.satom_->clone();
  string_ = other.string_;

}

EMatch &EMatch::operator=(const EMatch & other)
{
  EMatch tmp(other);
  swap(tmp);
  return *this;
}

void EMatch::swap(EMatch & other)
{
  std::swap(satom_, other.satom_);
  std::swap(string_, other.string_);

}

EMatch::~EMatch()
{
  delete(satom_);

}

QPointer<RetType> EMatch::accept(Visitor *v)
{
  return v->visitEMatch(this);
}

EMatch *EMatch::clone() const
{
  return new EMatch(*this);
}



/********************   ESEq    ********************/
ESEq::ESEq(SAtom *p1, SAtom *p2)
{
  satom_1 = p1;
  satom_2 = p2;

}

ESEq::ESEq(const ESEq & other)
{
  satom_1 = other.satom_1->clone();
  satom_2 = other.satom_2->clone();

}

ESEq &ESEq::operator=(const ESEq & other)
{
  ESEq tmp(other);
  swap(tmp);
  return *this;
}

void ESEq::swap(ESEq & other)
{
  std::swap(satom_1, other.satom_1);
  std::swap(satom_2, other.satom_2);

}

ESEq::~ESEq()
{
  delete(satom_1);
  delete(satom_2);

}

QPointer<RetType> ESEq::accept(Visitor *v)
{
  return v->visitESEq(this);
}

ESEq *ESEq::clone() const
{
  return new ESEq(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EAnd::~EAnd()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> EAnd::accept(Visitor *v)
{
  return v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EOr    ********************/
EOr::EOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EOr::EOr(const EOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EOr &EOr::operator=(const EOr & other)
{
  EOr tmp(other);
  swap(tmp);
  return *this;
}

void EOr::swap(EOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EOr::~EOr()
{
  delete(expr_1);
  delete(expr_2);

}

QPointer<RetType> EOr::accept(Visitor *v)
{
  return v->visitEOr(this);
}

EOr *EOr::clone() const
{
  return new EOr(*this);
}



/********************   EPQ    ********************/
EPQ::EPQ(PathQuantifier *p1)
{
  pathquantifier_ = p1;

}

EPQ::EPQ(const EPQ & other)
{
  pathquantifier_ = other.pathquantifier_->clone();

}

EPQ &EPQ::operator=(const EPQ & other)
{
  EPQ tmp(other);
  swap(tmp);
  return *this;
}

void EPQ::swap(EPQ & other)
{
  std::swap(pathquantifier_, other.pathquantifier_);

}

EPQ::~EPQ()
{
  delete(pathquantifier_);

}

QPointer<RetType> EPQ::accept(Visitor *v)
{
  return v->visitEPQ(this);
}

EPQ *EPQ::clone() const
{
  return new EPQ(*this);
}




/********************   ListRule    ********************/

QPointer<RetType> ListRule::accept(Visitor *v)
{
  return v->visitListRule(this);
}


ListRule *ListRule::clone() const
{
  return new ListRule(*this);
}


/********************   ListExpr    ********************/

QPointer<RetType> ListExpr::accept(Visitor *v)
{
  return v->visitListExpr(this);
}


ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}
