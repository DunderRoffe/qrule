#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

#include "retType/RetType.h"

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class RuleSet;
class Rule;
class ASTScope;
class RuleCause;
class Explanation;
class Tag;
class Severity;
class OverPaths;
class PathSpecific;
class IStmnt;
class IExpr;
class Expr;
class Type;
class Param;
class RSet;
class RRule;
class ASTGlobally;
class ASTFile;
class ASTImported;
class RCLang;
class RCPolicy;
class Explan;
class Noexplan;
class TTag;
class SevWarning;
class SevCritical;
class All;
class Exist;
class Future;
class Globally;
class Until;
class Next;
class IEInt;
class IENrChildren;
class IELtEq;
class IEGtEq;
class IELt;
class IEGt;
class IEq;
class IEStmnt;
class ETrue;
class EFalse;
class ENodeVal;
class EType;
class EParant;
class ENot;
class EImpl;
class EIExpr;
class EEq;
class EAnd;
class EOr;
class EOverPaths;
class TType;
class PParam;
class ListRule;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual RetType* visitRuleSet(RuleSet *p) = 0;
  virtual RetType* visitRule(Rule *p) = 0;
  virtual RetType* visitASTScope(ASTScope *p) = 0;
  virtual RetType* visitRuleCause(RuleCause *p) = 0;
  virtual RetType* visitExplanation(Explanation *p) = 0;
  virtual RetType* visitTag(Tag *p) = 0;
  virtual RetType* visitSeverity(Severity *p) = 0;
  virtual RetType* visitOverPaths(OverPaths *p) = 0;
  virtual RetType* visitPathSpecific(PathSpecific *p) = 0;
  virtual RetType* visitIStmnt(IStmnt *p) = 0;
  virtual RetType* visitIExpr(IExpr *p) = 0;
  virtual RetType* visitExpr(Expr *p) = 0;
  virtual RetType* visitType(Type *p) = 0;
  virtual RetType* visitParam(Param *p) = 0;
  virtual RetType* visitRSet(RSet *p) = 0;
  virtual RetType* visitRRule(RRule *p) = 0;
  virtual RetType* visitASTGlobally(ASTGlobally *p) = 0;
  virtual RetType* visitASTFile(ASTFile *p) = 0;
  virtual RetType* visitASTImported(ASTImported *p) = 0;
  virtual RetType* visitRCLang(RCLang *p) = 0;
  virtual RetType* visitRCPolicy(RCPolicy *p) = 0;
  virtual RetType* visitExplan(Explan *p) = 0;
  virtual RetType* visitNoexplan(Noexplan *p) = 0;
  virtual RetType* visitTTag(TTag *p) = 0;
  virtual RetType* visitSevWarning(SevWarning *p) = 0;
  virtual RetType* visitSevCritical(SevCritical *p) = 0;
  virtual RetType* visitAll(All *p) = 0;
  virtual RetType* visitExist(Exist *p) = 0;
  virtual RetType* visitFuture(Future *p) = 0;
  virtual RetType* visitGlobally(Globally *p) = 0;
  virtual RetType* visitUntil(Until *p) = 0;
  virtual RetType* visitNext(Next *p) = 0;
  virtual RetType* visitIEInt(IEInt *p) = 0;
  virtual RetType* visitIENrChildren(IENrChildren *p) = 0;
  virtual RetType* visitIELtEq(IELtEq *p) = 0;
  virtual RetType* visitIEGtEq(IEGtEq *p) = 0;
  virtual RetType* visitIELt(IELt *p) = 0;
  virtual RetType* visitIEGt(IEGt *p) = 0;
  virtual RetType* visitIEq(IEq *p) = 0;
  virtual RetType* visitIEStmnt(IEStmnt *p) = 0;
  virtual RetType* visitETrue(ETrue *p) = 0;
  virtual RetType* visitEFalse(EFalse *p) = 0;
  virtual RetType* visitENodeVal(ENodeVal *p) = 0;
  virtual RetType* visitEType(EType *p) = 0;
  virtual RetType* visitEParant(EParant *p) = 0;
  virtual RetType* visitENot(ENot *p) = 0;
  virtual RetType* visitEImpl(EImpl *p) = 0;
  virtual RetType* visitEIExpr(EIExpr *p) = 0;
  virtual RetType* visitEEq(EEq *p) = 0;
  virtual RetType* visitEAnd(EAnd *p) = 0;
  virtual RetType* visitEOr(EOr *p) = 0;
  virtual RetType* visitEOverPaths(EOverPaths *p) = 0;
  virtual RetType* visitTType(TType *p) = 0;
  virtual RetType* visitPParam(PParam *p) = 0;
  virtual RetType* visitListRule(ListRule *p) = 0;
  virtual RetType* visitListExpr(ListExpr *p) = 0;


  virtual RetType* visitInteger(Integer x) = 0;
  virtual RetType* visitChar(Char x) = 0;
  virtual RetType* visitDouble(Double x) = 0;
  virtual RetType* visitString(String x) = 0;
  virtual RetType* visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual RetType* accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class RuleSet : public Visitable
{
public:
  virtual RuleSet *clone() const = 0;

};

class Rule : public Visitable
{
public:
  virtual Rule *clone() const = 0;

};

class ASTScope : public Visitable
{
public:
  virtual ASTScope *clone() const = 0;

};

class RuleCause : public Visitable
{
public:
  virtual RuleCause *clone() const = 0;

};

class Explanation : public Visitable
{
public:
  virtual Explanation *clone() const = 0;

};

class Tag : public Visitable
{
public:
  virtual Tag *clone() const = 0;

};

class Severity : public Visitable
{
public:
  virtual Severity *clone() const = 0;

};

class OverPaths : public Visitable
{
public:
  virtual OverPaths *clone() const = 0;

};

class PathSpecific : public Visitable
{
public:
  virtual PathSpecific *clone() const = 0;

};

class IStmnt : public Visitable
{
public:
  virtual IStmnt *clone() const = 0;

};

class IExpr : public Visitable
{
public:
  virtual IExpr *clone() const = 0;

};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class Param : public Visitable
{
public:
  virtual Param *clone() const = 0;

};



class RSet : public RuleSet
{
public:
  ListRule *listrule_;

  RSet(const RSet &);
  RSet &operator=(const RSet &);
  RSet(ListRule *p1);
  ~RSet();
  virtual RetType* accept(Visitor *v);
  virtual RSet *clone() const;
  void swap(RSet &);
};

class RRule : public Rule
{
public:
  Tag *tag_;
  Severity *severity_;
  RuleCause *rulecause_;
  ASTScope *astscope_;
  Explanation *explanation_;
  Expr *expr_;

  RRule(const RRule &);
  RRule &operator=(const RRule &);
  RRule(Tag *p1, Severity *p2, RuleCause *p3, ASTScope *p4, Explanation *p5, Expr *p6);
  ~RRule();
  virtual RetType* accept(Visitor *v);
  virtual RRule *clone() const;
  void swap(RRule &);
};

class ASTGlobally : public ASTScope
{
public:

  ASTGlobally(const ASTGlobally &);
  ASTGlobally &operator=(const ASTGlobally &);
  ASTGlobally();
  ~ASTGlobally();
  virtual RetType* accept(Visitor *v);
  virtual ASTGlobally *clone() const;
  void swap(ASTGlobally &);
};

class ASTFile : public ASTScope
{
public:

  ASTFile(const ASTFile &);
  ASTFile &operator=(const ASTFile &);
  ASTFile();
  ~ASTFile();
  virtual RetType* accept(Visitor *v);
  virtual ASTFile *clone() const;
  void swap(ASTFile &);
};

class ASTImported : public ASTScope
{
public:

  ASTImported(const ASTImported &);
  ASTImported &operator=(const ASTImported &);
  ASTImported();
  ~ASTImported();
  virtual RetType* accept(Visitor *v);
  virtual ASTImported *clone() const;
  void swap(ASTImported &);
};

class RCLang : public RuleCause
{
public:

  RCLang(const RCLang &);
  RCLang &operator=(const RCLang &);
  RCLang();
  ~RCLang();
  virtual RetType* accept(Visitor *v);
  virtual RCLang *clone() const;
  void swap(RCLang &);
};

class RCPolicy : public RuleCause
{
public:

  RCPolicy(const RCPolicy &);
  RCPolicy &operator=(const RCPolicy &);
  RCPolicy();
  ~RCPolicy();
  virtual RetType* accept(Visitor *v);
  virtual RCPolicy *clone() const;
  void swap(RCPolicy &);
};

class Explan : public Explanation
{
public:
  String string_;

  Explan(const Explan &);
  Explan &operator=(const Explan &);
  Explan(String p1);
  ~Explan();
  virtual RetType* accept(Visitor *v);
  virtual Explan *clone() const;
  void swap(Explan &);
};

class Noexplan : public Explanation
{
public:

  Noexplan(const Noexplan &);
  Noexplan &operator=(const Noexplan &);
  Noexplan();
  ~Noexplan();
  virtual RetType* accept(Visitor *v);
  virtual Noexplan *clone() const;
  void swap(Noexplan &);
};

class TTag : public Tag
{
public:
  String string_;

  TTag(const TTag &);
  TTag &operator=(const TTag &);
  TTag(String p1);
  ~TTag();
  virtual RetType* accept(Visitor *v);
  virtual TTag *clone() const;
  void swap(TTag &);
};

class SevWarning : public Severity
{
public:

  SevWarning(const SevWarning &);
  SevWarning &operator=(const SevWarning &);
  SevWarning();
  ~SevWarning();
  virtual RetType* accept(Visitor *v);
  virtual SevWarning *clone() const;
  void swap(SevWarning &);
};

class SevCritical : public Severity
{
public:

  SevCritical(const SevCritical &);
  SevCritical &operator=(const SevCritical &);
  SevCritical();
  ~SevCritical();
  virtual RetType* accept(Visitor *v);
  virtual SevCritical *clone() const;
  void swap(SevCritical &);
};

class All : public OverPaths
{
public:
  PathSpecific *pathspecific_;

  All(const All &);
  All &operator=(const All &);
  All(PathSpecific *p1);
  ~All();
  virtual RetType* accept(Visitor *v);
  virtual All *clone() const;
  void swap(All &);
};

class Exist : public OverPaths
{
public:
  PathSpecific *pathspecific_;

  Exist(const Exist &);
  Exist &operator=(const Exist &);
  Exist(PathSpecific *p1);
  ~Exist();
  virtual RetType* accept(Visitor *v);
  virtual Exist *clone() const;
  void swap(Exist &);
};

class Future : public PathSpecific
{
public:
  Expr *expr_;

  Future(const Future &);
  Future &operator=(const Future &);
  Future(Expr *p1);
  ~Future();
  virtual RetType* accept(Visitor *v);
  virtual Future *clone() const;
  void swap(Future &);
};

class Globally : public PathSpecific
{
public:
  Expr *expr_;

  Globally(const Globally &);
  Globally &operator=(const Globally &);
  Globally(Expr *p1);
  ~Globally();
  virtual RetType* accept(Visitor *v);
  virtual Globally *clone() const;
  void swap(Globally &);
};

class Until : public PathSpecific
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Until(const Until &);
  Until &operator=(const Until &);
  Until(Expr *p1, Expr *p2);
  ~Until();
  virtual RetType* accept(Visitor *v);
  virtual Until *clone() const;
  void swap(Until &);
};

class Next : public PathSpecific
{
public:
  Expr *expr_;

  Next(const Next &);
  Next &operator=(const Next &);
  Next(Expr *p1);
  ~Next();
  virtual RetType* accept(Visitor *v);
  virtual Next *clone() const;
  void swap(Next &);
};

class IEInt : public IStmnt
{
public:
  Integer integer_;

  IEInt(const IEInt &);
  IEInt &operator=(const IEInt &);
  IEInt(Integer p1);
  ~IEInt();
  virtual RetType* accept(Visitor *v);
  virtual IEInt *clone() const;
  void swap(IEInt &);
};

class IENrChildren : public IStmnt
{
public:

  IENrChildren(const IENrChildren &);
  IENrChildren &operator=(const IENrChildren &);
  IENrChildren();
  ~IENrChildren();
  virtual RetType* accept(Visitor *v);
  virtual IENrChildren *clone() const;
  void swap(IENrChildren &);
};

class IELtEq : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IELtEq(const IELtEq &);
  IELtEq &operator=(const IELtEq &);
  IELtEq(IExpr *p1, IStmnt *p2);
  ~IELtEq();
  virtual RetType* accept(Visitor *v);
  virtual IELtEq *clone() const;
  void swap(IELtEq &);
};

class IEGtEq : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IEGtEq(const IEGtEq &);
  IEGtEq &operator=(const IEGtEq &);
  IEGtEq(IExpr *p1, IStmnt *p2);
  ~IEGtEq();
  virtual RetType* accept(Visitor *v);
  virtual IEGtEq *clone() const;
  void swap(IEGtEq &);
};

class IELt : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IELt(const IELt &);
  IELt &operator=(const IELt &);
  IELt(IExpr *p1, IStmnt *p2);
  ~IELt();
  virtual RetType* accept(Visitor *v);
  virtual IELt *clone() const;
  void swap(IELt &);
};

class IEGt : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IEGt(const IEGt &);
  IEGt &operator=(const IEGt &);
  IEGt(IExpr *p1, IStmnt *p2);
  ~IEGt();
  virtual RetType* accept(Visitor *v);
  virtual IEGt *clone() const;
  void swap(IEGt &);
};

class IEq : public IExpr
{
public:
  IStmnt *istmnt_1;
  IStmnt *istmnt_2;

  IEq(const IEq &);
  IEq &operator=(const IEq &);
  IEq(IStmnt *p1, IStmnt *p2);
  ~IEq();
  virtual RetType* accept(Visitor *v);
  virtual IEq *clone() const;
  void swap(IEq &);
};

class IEStmnt : public IExpr
{
public:
  IStmnt *istmnt_;

  IEStmnt(const IEStmnt &);
  IEStmnt &operator=(const IEStmnt &);
  IEStmnt(IStmnt *p1);
  ~IEStmnt();
  virtual RetType* accept(Visitor *v);
  virtual IEStmnt *clone() const;
  void swap(IEStmnt &);
};

class ETrue : public Expr
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual RetType* accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);
};

class EFalse : public Expr
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual RetType* accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);
};

class ENodeVal : public Expr
{
public:
  String string_;

  ENodeVal(const ENodeVal &);
  ENodeVal &operator=(const ENodeVal &);
  ENodeVal(String p1);
  ~ENodeVal();
  virtual RetType* accept(Visitor *v);
  virtual ENodeVal *clone() const;
  void swap(ENodeVal &);
};

class EType : public Expr
{
public:
  Type *type_;

  EType(const EType &);
  EType &operator=(const EType &);
  EType(Type *p1);
  ~EType();
  virtual RetType* accept(Visitor *v);
  virtual EType *clone() const;
  void swap(EType &);
};

class EParant : public Expr
{
public:
  Expr *expr_;

  EParant(const EParant &);
  EParant &operator=(const EParant &);
  EParant(Expr *p1);
  ~EParant();
  virtual RetType* accept(Visitor *v);
  virtual EParant *clone() const;
  void swap(EParant &);
};

class ENot : public Expr
{
public:
  Expr *expr_;

  ENot(const ENot &);
  ENot &operator=(const ENot &);
  ENot(Expr *p1);
  ~ENot();
  virtual RetType* accept(Visitor *v);
  virtual ENot *clone() const;
  void swap(ENot &);
};

class EImpl : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EImpl(const EImpl &);
  EImpl &operator=(const EImpl &);
  EImpl(Expr *p1, Expr *p2);
  ~EImpl();
  virtual RetType* accept(Visitor *v);
  virtual EImpl *clone() const;
  void swap(EImpl &);
};

class EIExpr : public Expr
{
public:
  IExpr *iexpr_;

  EIExpr(const EIExpr &);
  EIExpr &operator=(const EIExpr &);
  EIExpr(IExpr *p1);
  ~EIExpr();
  virtual RetType* accept(Visitor *v);
  virtual EIExpr *clone() const;
  void swap(EIExpr &);
};

class EEq : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Expr *p1, Expr *p2);
  ~EEq();
  virtual RetType* accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class EAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Expr *p1, Expr *p2);
  ~EAnd();
  virtual RetType* accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Expr *p1, Expr *p2);
  ~EOr();
  virtual RetType* accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class EOverPaths : public Expr
{
public:
  OverPaths *overpaths_;

  EOverPaths(const EOverPaths &);
  EOverPaths &operator=(const EOverPaths &);
  EOverPaths(OverPaths *p1);
  ~EOverPaths();
  virtual RetType* accept(Visitor *v);
  virtual EOverPaths *clone() const;
  void swap(EOverPaths &);
};

class TType : public Type
{
public:
  String string_;

  TType(const TType &);
  TType &operator=(const TType &);
  TType(String p1);
  ~TType();
  virtual RetType* accept(Visitor *v);
  virtual TType *clone() const;
  void swap(TType &);
};

class PParam : public Param
{
public:
  String string_;

  PParam(const PParam &);
  PParam &operator=(const PParam &);
  PParam(String p1);
  ~PParam();
  virtual RetType* accept(Visitor *v);
  virtual PParam *clone() const;
  void swap(PParam &);
};



class ListRule : public Visitable, public std::vector<Rule*>
{
public:
  virtual RetType* accept(Visitor *v);
  virtual ListRule *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual RetType* accept(Visitor *v);
  virtual ListExpr *clone() const;
};



#endif
