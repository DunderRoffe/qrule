#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

#include <retType/RetType.h>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class RuleSet;
class Rule;
class ASTScope;
class RuleCause;
class Explanation;
class Tag;
class Severity;
class PathQuantifier;
class IStmnt;
class IExpr;
class Expr;
class RSet;
class RRule;
class ASTGlobally;
class ASTFile;
class ASTImported;
class RCLang;
class RCPolicy;
class Explan;
class Noexplan;
class TTag;
class SevWarning;
class SevCritical;
class AG;
class AF;
class AX;
class AU;
class EG;
class EF;
class EX;
class EU;
class IEInt;
class IENrChildren;
class IERow;
class IECol;
class IELtEq;
class IEGtEq;
class IELt;
class IEGt;
class IEq;
class IEStmnt;
class ETrue;
class EFalse;
class EValue;
class EValueType;
class ENodeType;
class EParant;
class ENot;
class EImpl;
class EIExpr;
class EEq;
class EAnd;
class EOr;
class EPQ;
class ListRule;
class ListExpr;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual RetType* visitRuleSet(RuleSet *p) = 0;
  virtual RetType* visitRule(Rule *p) = 0;
  virtual RetType* visitASTScope(ASTScope *p) = 0;
  virtual RetType* visitRuleCause(RuleCause *p) = 0;
  virtual RetType* visitExplanation(Explanation *p) = 0;
  virtual RetType* visitTag(Tag *p) = 0;
  virtual RetType* visitSeverity(Severity *p) = 0;
  virtual RetType* visitPathQuantifier(PathQuantifier *p) = 0;
  virtual RetType* visitIStmnt(IStmnt *p) = 0;
  virtual RetType* visitIExpr(IExpr *p) = 0;
  virtual RetType* visitExpr(Expr *p) = 0;
  virtual RetType* visitRSet(RSet *p) = 0;
  virtual RetType* visitRRule(RRule *p) = 0;
  virtual RetType* visitASTGlobally(ASTGlobally *p) = 0;
  virtual RetType* visitASTFile(ASTFile *p) = 0;
  virtual RetType* visitASTImported(ASTImported *p) = 0;
  virtual RetType* visitRCLang(RCLang *p) = 0;
  virtual RetType* visitRCPolicy(RCPolicy *p) = 0;
  virtual RetType* visitExplan(Explan *p) = 0;
  virtual RetType* visitNoexplan(Noexplan *p) = 0;
  virtual RetType* visitTTag(TTag *p) = 0;
  virtual RetType* visitSevWarning(SevWarning *p) = 0;
  virtual RetType* visitSevCritical(SevCritical *p) = 0;
  virtual RetType* visitAG(AG *p) = 0;
  virtual RetType* visitAF(AF *p) = 0;
  virtual RetType* visitAX(AX *p) = 0;
  virtual RetType* visitAU(AU *p) = 0;
  virtual RetType* visitEG(EG *p) = 0;
  virtual RetType* visitEF(EF *p) = 0;
  virtual RetType* visitEX(EX *p) = 0;
  virtual RetType* visitEU(EU *p) = 0;
  virtual RetType* visitIEInt(IEInt *p) = 0;
  virtual RetType* visitIENrChildren(IENrChildren *p) = 0;
  virtual RetType* visitIERow(IERow *p) = 0;
  virtual RetType* visitIECol(IECol *p) = 0;
  virtual RetType* visitIELtEq(IELtEq *p) = 0;
  virtual RetType* visitIEGtEq(IEGtEq *p) = 0;
  virtual RetType* visitIELt(IELt *p) = 0;
  virtual RetType* visitIEGt(IEGt *p) = 0;
  virtual RetType* visitIEq(IEq *p) = 0;
  virtual RetType* visitIEStmnt(IEStmnt *p) = 0;
  virtual RetType* visitETrue(ETrue *p) = 0;
  virtual RetType* visitEFalse(EFalse *p) = 0;
  virtual RetType* visitEValue(EValue *p) = 0;
  virtual RetType* visitEValueType(EValueType *p) = 0;
  virtual RetType* visitENodeType(ENodeType *p) = 0;
  virtual RetType* visitEParant(EParant *p) = 0;
  virtual RetType* visitENot(ENot *p) = 0;
  virtual RetType* visitEImpl(EImpl *p) = 0;
  virtual RetType* visitEIExpr(EIExpr *p) = 0;
  virtual RetType* visitEEq(EEq *p) = 0;
  virtual RetType* visitEAnd(EAnd *p) = 0;
  virtual RetType* visitEOr(EOr *p) = 0;
  virtual RetType* visitEPQ(EPQ *p) = 0;
  virtual RetType* visitListRule(ListRule *p) = 0;
  virtual RetType* visitListExpr(ListExpr *p) = 0;


  virtual RetType* visitInteger(Integer x) = 0;
  virtual RetType* visitChar(Char x) = 0;
  virtual RetType* visitDouble(Double x) = 0;
  virtual RetType* visitString(String x) = 0;
  virtual RetType* visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual RetType* accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class RuleSet : public Visitable
{
public:
  virtual RuleSet *clone() const = 0;

};

class Rule : public Visitable
{
public:
  virtual Rule *clone() const = 0;

};

class ASTScope : public Visitable
{
public:
  virtual ASTScope *clone() const = 0;

};

class RuleCause : public Visitable
{
public:
  virtual RuleCause *clone() const = 0;

};

class Explanation : public Visitable
{
public:
  virtual Explanation *clone() const = 0;

};

class Tag : public Visitable
{
public:
  virtual Tag *clone() const = 0;

};

class Severity : public Visitable
{
public:
  virtual Severity *clone() const = 0;

};

class PathQuantifier : public Visitable
{
public:
  virtual PathQuantifier *clone() const = 0;

};

class IStmnt : public Visitable
{
public:
  virtual IStmnt *clone() const = 0;

};

class IExpr : public Visitable
{
public:
  virtual IExpr *clone() const = 0;

};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;

};



class RSet : public RuleSet
{
public:
  ListRule *listrule_;

  RSet(const RSet &);
  RSet &operator=(const RSet &);
  RSet(ListRule *p1);
  ~RSet();
  virtual RetType* accept(Visitor *v);
  virtual RSet *clone() const;
  void swap(RSet &);
};

class RRule : public Rule
{
public:
  Tag *tag_;
  Severity *severity_;
  RuleCause *rulecause_;
  ASTScope *astscope_;
  Explanation *explanation_;
  Expr *expr_;

  RRule(const RRule &);
  RRule &operator=(const RRule &);
  RRule(Tag *p1, Severity *p2, RuleCause *p3, ASTScope *p4, Explanation *p5, Expr *p6);
  ~RRule();
  virtual RetType* accept(Visitor *v);
  virtual RRule *clone() const;
  void swap(RRule &);
};

class ASTGlobally : public ASTScope
{
public:

  ASTGlobally(const ASTGlobally &);
  ASTGlobally &operator=(const ASTGlobally &);
  ASTGlobally();
  ~ASTGlobally();
  virtual RetType* accept(Visitor *v);
  virtual ASTGlobally *clone() const;
  void swap(ASTGlobally &);
};

class ASTFile : public ASTScope
{
public:

  ASTFile(const ASTFile &);
  ASTFile &operator=(const ASTFile &);
  ASTFile();
  ~ASTFile();
  virtual RetType* accept(Visitor *v);
  virtual ASTFile *clone() const;
  void swap(ASTFile &);
};

class ASTImported : public ASTScope
{
public:

  ASTImported(const ASTImported &);
  ASTImported &operator=(const ASTImported &);
  ASTImported();
  ~ASTImported();
  virtual RetType* accept(Visitor *v);
  virtual ASTImported *clone() const;
  void swap(ASTImported &);
};

class RCLang : public RuleCause
{
public:

  RCLang(const RCLang &);
  RCLang &operator=(const RCLang &);
  RCLang();
  ~RCLang();
  virtual RetType* accept(Visitor *v);
  virtual RCLang *clone() const;
  void swap(RCLang &);
};

class RCPolicy : public RuleCause
{
public:

  RCPolicy(const RCPolicy &);
  RCPolicy &operator=(const RCPolicy &);
  RCPolicy();
  ~RCPolicy();
  virtual RetType* accept(Visitor *v);
  virtual RCPolicy *clone() const;
  void swap(RCPolicy &);
};

class Explan : public Explanation
{
public:
  String string_;

  Explan(const Explan &);
  Explan &operator=(const Explan &);
  Explan(String p1);
  ~Explan();
  virtual RetType* accept(Visitor *v);
  virtual Explan *clone() const;
  void swap(Explan &);
};

class Noexplan : public Explanation
{
public:

  Noexplan(const Noexplan &);
  Noexplan &operator=(const Noexplan &);
  Noexplan();
  ~Noexplan();
  virtual RetType* accept(Visitor *v);
  virtual Noexplan *clone() const;
  void swap(Noexplan &);
};

class TTag : public Tag
{
public:
  String string_;

  TTag(const TTag &);
  TTag &operator=(const TTag &);
  TTag(String p1);
  ~TTag();
  virtual RetType* accept(Visitor *v);
  virtual TTag *clone() const;
  void swap(TTag &);
};

class SevWarning : public Severity
{
public:

  SevWarning(const SevWarning &);
  SevWarning &operator=(const SevWarning &);
  SevWarning();
  ~SevWarning();
  virtual RetType* accept(Visitor *v);
  virtual SevWarning *clone() const;
  void swap(SevWarning &);
};

class SevCritical : public Severity
{
public:

  SevCritical(const SevCritical &);
  SevCritical &operator=(const SevCritical &);
  SevCritical();
  ~SevCritical();
  virtual RetType* accept(Visitor *v);
  virtual SevCritical *clone() const;
  void swap(SevCritical &);
};

class AG : public PathQuantifier
{
public:
  Expr *expr_;

  AG(const AG &);
  AG &operator=(const AG &);
  AG(Expr *p1);
  ~AG();
  virtual RetType* accept(Visitor *v);
  virtual AG *clone() const;
  void swap(AG &);
};

class AF : public PathQuantifier
{
public:
  Expr *expr_;

  AF(const AF &);
  AF &operator=(const AF &);
  AF(Expr *p1);
  ~AF();
  virtual RetType* accept(Visitor *v);
  virtual AF *clone() const;
  void swap(AF &);
};

class AX : public PathQuantifier
{
public:
  Expr *expr_;

  AX(const AX &);
  AX &operator=(const AX &);
  AX(Expr *p1);
  ~AX();
  virtual RetType* accept(Visitor *v);
  virtual AX *clone() const;
  void swap(AX &);
};

class AU : public PathQuantifier
{
public:
  Expr *expr_1;
  Expr *expr_2;

  AU(const AU &);
  AU &operator=(const AU &);
  AU(Expr *p1, Expr *p2);
  ~AU();
  virtual RetType* accept(Visitor *v);
  virtual AU *clone() const;
  void swap(AU &);
};

class EG : public PathQuantifier
{
public:
  Expr *expr_;

  EG(const EG &);
  EG &operator=(const EG &);
  EG(Expr *p1);
  ~EG();
  virtual RetType* accept(Visitor *v);
  virtual EG *clone() const;
  void swap(EG &);
};

class EF : public PathQuantifier
{
public:
  Expr *expr_;

  EF(const EF &);
  EF &operator=(const EF &);
  EF(Expr *p1);
  ~EF();
  virtual RetType* accept(Visitor *v);
  virtual EF *clone() const;
  void swap(EF &);
};

class EX : public PathQuantifier
{
public:
  Expr *expr_;

  EX(const EX &);
  EX &operator=(const EX &);
  EX(Expr *p1);
  ~EX();
  virtual RetType* accept(Visitor *v);
  virtual EX *clone() const;
  void swap(EX &);
};

class EU : public PathQuantifier
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EU(const EU &);
  EU &operator=(const EU &);
  EU(Expr *p1, Expr *p2);
  ~EU();
  virtual RetType* accept(Visitor *v);
  virtual EU *clone() const;
  void swap(EU &);
};

class IEInt : public IStmnt
{
public:
  Integer integer_;

  IEInt(const IEInt &);
  IEInt &operator=(const IEInt &);
  IEInt(Integer p1);
  ~IEInt();
  virtual RetType* accept(Visitor *v);
  virtual IEInt *clone() const;
  void swap(IEInt &);
};

class IENrChildren : public IStmnt
{
public:

  IENrChildren(const IENrChildren &);
  IENrChildren &operator=(const IENrChildren &);
  IENrChildren();
  ~IENrChildren();
  virtual RetType* accept(Visitor *v);
  virtual IENrChildren *clone() const;
  void swap(IENrChildren &);
};

class IERow : public IStmnt
{
public:

  IERow(const IERow &);
  IERow &operator=(const IERow &);
  IERow();
  ~IERow();
  virtual RetType* accept(Visitor *v);
  virtual IERow *clone() const;
  void swap(IERow &);
};

class IECol : public IStmnt
{
public:

  IECol(const IECol &);
  IECol &operator=(const IECol &);
  IECol();
  ~IECol();
  virtual RetType* accept(Visitor *v);
  virtual IECol *clone() const;
  void swap(IECol &);
};

class IELtEq : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IELtEq(const IELtEq &);
  IELtEq &operator=(const IELtEq &);
  IELtEq(IExpr *p1, IStmnt *p2);
  ~IELtEq();
  virtual RetType* accept(Visitor *v);
  virtual IELtEq *clone() const;
  void swap(IELtEq &);
};

class IEGtEq : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IEGtEq(const IEGtEq &);
  IEGtEq &operator=(const IEGtEq &);
  IEGtEq(IExpr *p1, IStmnt *p2);
  ~IEGtEq();
  virtual RetType* accept(Visitor *v);
  virtual IEGtEq *clone() const;
  void swap(IEGtEq &);
};

class IELt : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IELt(const IELt &);
  IELt &operator=(const IELt &);
  IELt(IExpr *p1, IStmnt *p2);
  ~IELt();
  virtual RetType* accept(Visitor *v);
  virtual IELt *clone() const;
  void swap(IELt &);
};

class IEGt : public IExpr
{
public:
  IExpr *iexpr_;
  IStmnt *istmnt_;

  IEGt(const IEGt &);
  IEGt &operator=(const IEGt &);
  IEGt(IExpr *p1, IStmnt *p2);
  ~IEGt();
  virtual RetType* accept(Visitor *v);
  virtual IEGt *clone() const;
  void swap(IEGt &);
};

class IEq : public IExpr
{
public:
  IStmnt *istmnt_1;
  IStmnt *istmnt_2;

  IEq(const IEq &);
  IEq &operator=(const IEq &);
  IEq(IStmnt *p1, IStmnt *p2);
  ~IEq();
  virtual RetType* accept(Visitor *v);
  virtual IEq *clone() const;
  void swap(IEq &);
};

class IEStmnt : public IExpr
{
public:
  IStmnt *istmnt_;

  IEStmnt(const IEStmnt &);
  IEStmnt &operator=(const IEStmnt &);
  IEStmnt(IStmnt *p1);
  ~IEStmnt();
  virtual RetType* accept(Visitor *v);
  virtual IEStmnt *clone() const;
  void swap(IEStmnt &);
};

class ETrue : public Expr
{
public:

  ETrue(const ETrue &);
  ETrue &operator=(const ETrue &);
  ETrue();
  ~ETrue();
  virtual RetType* accept(Visitor *v);
  virtual ETrue *clone() const;
  void swap(ETrue &);
};

class EFalse : public Expr
{
public:

  EFalse(const EFalse &);
  EFalse &operator=(const EFalse &);
  EFalse();
  ~EFalse();
  virtual RetType* accept(Visitor *v);
  virtual EFalse *clone() const;
  void swap(EFalse &);
};

class EValue : public Expr
{
public:
  String string_;

  EValue(const EValue &);
  EValue &operator=(const EValue &);
  EValue(String p1);
  ~EValue();
  virtual RetType* accept(Visitor *v);
  virtual EValue *clone() const;
  void swap(EValue &);
};

class EValueType : public Expr
{
public:
  String string_;

  EValueType(const EValueType &);
  EValueType &operator=(const EValueType &);
  EValueType(String p1);
  ~EValueType();
  virtual RetType* accept(Visitor *v);
  virtual EValueType *clone() const;
  void swap(EValueType &);
};

class ENodeType : public Expr
{
public:
  String string_;

  ENodeType(const ENodeType &);
  ENodeType &operator=(const ENodeType &);
  ENodeType(String p1);
  ~ENodeType();
  virtual RetType* accept(Visitor *v);
  virtual ENodeType *clone() const;
  void swap(ENodeType &);
};

class EParant : public Expr
{
public:
  Expr *expr_;

  EParant(const EParant &);
  EParant &operator=(const EParant &);
  EParant(Expr *p1);
  ~EParant();
  virtual RetType* accept(Visitor *v);
  virtual EParant *clone() const;
  void swap(EParant &);
};

class ENot : public Expr
{
public:
  Expr *expr_;

  ENot(const ENot &);
  ENot &operator=(const ENot &);
  ENot(Expr *p1);
  ~ENot();
  virtual RetType* accept(Visitor *v);
  virtual ENot *clone() const;
  void swap(ENot &);
};

class EImpl : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EImpl(const EImpl &);
  EImpl &operator=(const EImpl &);
  EImpl(Expr *p1, Expr *p2);
  ~EImpl();
  virtual RetType* accept(Visitor *v);
  virtual EImpl *clone() const;
  void swap(EImpl &);
};

class EIExpr : public Expr
{
public:
  IExpr *iexpr_;

  EIExpr(const EIExpr &);
  EIExpr &operator=(const EIExpr &);
  EIExpr(IExpr *p1);
  ~EIExpr();
  virtual RetType* accept(Visitor *v);
  virtual EIExpr *clone() const;
  void swap(EIExpr &);
};

class EEq : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EEq(const EEq &);
  EEq &operator=(const EEq &);
  EEq(Expr *p1, Expr *p2);
  ~EEq();
  virtual RetType* accept(Visitor *v);
  virtual EEq *clone() const;
  void swap(EEq &);
};

class EAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EAnd(const EAnd &);
  EAnd &operator=(const EAnd &);
  EAnd(Expr *p1, Expr *p2);
  ~EAnd();
  virtual RetType* accept(Visitor *v);
  virtual EAnd *clone() const;
  void swap(EAnd &);
};

class EOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EOr(const EOr &);
  EOr &operator=(const EOr &);
  EOr(Expr *p1, Expr *p2);
  ~EOr();
  virtual RetType* accept(Visitor *v);
  virtual EOr *clone() const;
  void swap(EOr &);
};

class EPQ : public Expr
{
public:
  PathQuantifier *pathquantifier_;

  EPQ(const EPQ &);
  EPQ &operator=(const EPQ &);
  EPQ(PathQuantifier *p1);
  ~EPQ();
  virtual RetType* accept(Visitor *v);
  virtual EPQ *clone() const;
  void swap(EPQ &);
};



class ListRule : public Visitable, public std::vector<Rule*>
{
public:
  virtual RetType* accept(Visitor *v);
  virtual ListRule *clone() const;
};

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual RetType* accept(Visitor *v);
  virtual ListExpr *clone() const;
};



#endif
